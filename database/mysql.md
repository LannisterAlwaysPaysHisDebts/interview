# 引擎,隔离级别
## InnoDB、MyISAM的区别?各自使用的索引?
1. InnoDB支持事务，MyISAM 不支持事务;
2. InnoDB支持外键，而MyISAM不支持; 
3. InnoDB是聚簇索引，MyISAM是非聚簇索引。
4. InnoDB不保存表的具体行数，执行`select count(*) from table`时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；
5. InnoDB最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。
6. MyISAM在备份的时候需要对表加锁来保证数据的一致性,InnoDB支持热备份,通过事务和MVCC
7. InnoDB在5.7.8之后支持JSON数据类型了;

由于InnoDB的发展与日益强大，目前在绝大多数场景下选择这一种存储引擎即可，除了一些极特别的应用场景，其实没有理由再去选择其他的存储引擎。


## 为什么innodb查询count(*)会很慢? 为什么不和MyISAM一样全局存储一个count数?
- 因为innodb中的MVCC给每行数据保存了两个额外的字段:创建版本号与删除版本号; 
- 由于每一行数据都需要判断自己是否对这个事务可见，所以InnoDB就必须把数据一行一行的全部读出，然后进行判断。版本号小于当前事务的，或者没有行删除标记的，才会被纳入统计的表的总行数。


## 简述关系型数据库与非关系形数据库的区别与联系
- 存储方式: 关系型数据库是表格式的，数据存储在表的行和列中;Nosql数据库是大块的组合在一起,通常存储在数据集中，就像文档、键值对或者图结构;
- 存储结构: 关系型数据库是结构化数据,数据表都预先定义了结构;Nosql数据库基于动态结构，使用与非结构化数据。 
- 存储规范: 关系型数据库的数据存储为了更高的规范性，把数据分割为最小的关系表以避免重复，获得精简的空间利用。而Nosql数据存储在平面数据集中，数据经常可能会重复。单个数据库很少被分隔开，而是存储成了一个整体，这样整块数据更加便于读写;
- 存储扩展: 关系型数据库一般是纵向扩展,也就是说想要提高处理能力，要使用速度更快的计算机;而Nosql数据库是横向扩展的，它的存储天然就是分布式的，可以通过给资源池添加更多的普通数据库服务器来分担负载。
- 查询方式: 关系型数据库通过结构化查询语言来操作数据库(sql),而Nosql查询以块为单元操作数据，使用的是非结构化查询语言;关系型数据库使用预定义优化方式（比如索引）来加快查询操作，而Nosql更简单更精确的数据访问模式。
- 事务: 关系型数据库遵循ACID（原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)）规则、Nosql数据库遵循BASE（基本可用（Basically Availble）、软/柔性事务（Soft-state ）、最终一致性（Eventual Consistency））原则;关系型数据库支持对事务原子性细粒度控制，并且易于回滚事务。而Nosql数据库是在CAP（一致性、可用性、分区容忍度）中任选两项，因为基于节点的分布式系统中，很难全部满足，所以对事务的支持不是很好，虽然也可以使用事务，但是并不是Nosql的闪光点。


## 简述ACID
- 原子性(Atomicity): 事务是一个不可再分割的工作单元;
- 一致性(Consistency): 事务开始之前和事务结束以后，数据库的完整性约束(比如唯一索引)没有被破坏;
- 隔离性(Isolation): 多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果;
- 持久性(Durability): 在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚;
    

## 讲一讲mysql的优化思路?
选择合理的数据库引擎;选择合适的字段类型;部分字段建立索引;主从复制读写分离;分库分表;

## 讲一讲sql语句的优化思路?
基本思路是基于代价估算模型对 SQL 语句进行调优，找出代价最小的那个执行方式。扫描算法多表连接算法方面mysql的查询优化器已经做的足够好了,不需要我们干预;我们重点优化**数据扫描**和**索引**


## 如何分析SQL执行慢的原因
流程:
1. 是否存在周期波动? 是=> 加缓存、更改缓存失效策略;
2. 开启慢查询, `EXPLAIN SHOW PROFILING`, 如果:
    1. sql等待时间长 => 调优服务器参数;
    2. sql执行时间长 => 索引设计优化;JOIN表过多?数据表设计优化;
    3. 如果1、2都没有解决问题,考虑是否是sql查询到达了服务器瓶颈 => 1. 读写分离; 2. 分库分表(垂直分库、垂直分表、水平分表)

## 一条mysql数据是怎么查出来的?

一条sql语句在执行过程中需要经过连接器、分析器、优化器、执行器等，也有可能会经过查询缓存:
- 连接器: 负责与客户端建立连接、获取权限、维持和管理连接
- 查询缓存: MySql拿到查询后，会先到查询缓存查看是否执行过这条语句;在MySql8.0之后去掉了查询缓存的功能。
- 分析器: 词法分析,识别出sql里的字符串分别是什么，“select”代表这是一条查询语句,T转换称“表T”;语法分析:根据词法分析的结果，判断该条sql是否满足MySql的语法
- 优化器: 优化器的作用在于选择最优的逻辑执行sql;
- 执行器: 在开始执行前，先判断你对表T是否有执行查询的权限;执行器根据表的引擎定义，调用该引擎提供的接口。


## innodb有哪些隔离级别?不可重复读和幻读分别是在哪个隔离级别解决的?幻读解决的原理, gap? mvcc索引种类和区别?
> [MySQL事务隔离级别和实现原理](https://zhuanlan.zhihu.com/p/117476959)

在不同的隔离级别下，数据库通过MVCC和隔离级别，让事务之间并行操作遵循了某种规则，来保证单个事务内前后数据的一致性。

前置知识: 
- 脏读:指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了不一定最终存在的数据，这就是脏读。
- 可重复读:指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。通常针对数据更新（UPDATE）操作。
- 不可重复读:对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据更新（UPDATE）操作。
- 幻读:幻读是针对数据插入（INSERT）操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。

|隔离级别|脏读|不可重复读|幻读|
|---|---|---|---|
|读未提交（READ UNCOMMITTED）|可能|可能|可能|
|读提交 （READ COMMITTED）|不可能|可能|可能|
|可重复读 （REPEATABLE READ）|不可能|不可能|可能|
|串行化 （SERIALIZABLE）|不可能|不可能|不可能|

从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，*可重复读*是MySQL的默认级别。

GAP间隙锁: mysql底层通过间隙锁来解决可重复读级别下幻读的问题. 间隙锁实质是对索引的前后间隙上锁,不对索引本身上锁。根据检索条件向左寻找最靠近检索条件的记录值A，作为左区间，向右寻找最靠近检索条件的记录值B作为右区间，即锁定的间隙为（A，B）。

GAP防止:1. 防止间隙内有新数据被插入; 2. 防止已存在的数据，更新成间隙内的数;

GAP要求: where条件字段是整型主键;

MVCC: 
- innodb有个版本号,每启动一次事务版本号都会增加;
- 在每行数据后面增加了两个字段: 创建时间与删除时间;
- insert时创建时间设置为当前版本号;
- delete时删除时间设置为当前版本号;
- select时,只可查询到: 创建时间小于等于当前版本号的,并且删除时间为空或者大于当前版本号;
- update时,插入一条新记录,并且原来行的删除时间记录为当前版本号;

## 有用过MySQL的什么高级特性吗?讲一下
见高性能mysql第七章, 这里挑几个写一下:
- 分区表
- 视图
- 外键约束
- 游标
- 全文索引
- 分布式XA事务
- 查询缓存
    

## 为什么选InnoDB?
几乎所有公司用MySQL都用InnoDB，降低踩坑成本；

1. 支持事务;
2. 支持行锁;
3. MVCC;
4. Next-Key锁解决幻读问题;
5. 完整支持ACID;
6. 一致性非锁定读;
7. 支持热备, 开启一个事务即可;
8. 支持json;
9. 5.6以后支持online ddl


## mysql语句性能评测？
> 见 高性能mysql 附录EXPLAIN

使用EXPLAIN(在5.6以后非select语句也能使用).比较重要的列有:

|列|解析|
|:--|---|
|type|访问类型.const：表示通过索引一次就找到了;eq_ref：通过唯一索引扫描整个表;ref：非唯一性索引扫描;range：where语句中出现了bettween、<、>、in等的查询;index：index与ALL区别为index类型只遍历索引树。ALL: 全表扫描。|
|key|MySQL实际采用哪个索引|
|rows|查询优化器预估需要读取的行数|
|Extra|Using index: 从索引中就可以查询到最终需要的信息，不需要再读取表;Using where ：表示优化器需要通过索引回表查询数据;Using temporary: 对查询结果排序时使用了临时表，常见于order by 和 group by;Using filesort: MySQL中无法利用索引完成的排序操作称为”文件排序”|


## 你处理过最大表的数据量级是多少? 分表的策略,分表下的利弊,分表下不同查询维度如何实现?以及你对双向表的理解?
分表了一个弊端，即数据冗余
然后说优势，减少单个表的索引大学，加快查询速度，多个表也可以支持并发插入
// todo

## 谈谈你对分区表的理解?
- 在创建表的时候,使用`partition by`关键字来分区;
- 整体来看仍然是一个表,但是会分若干个idb文件存储,说明对业务是透明的;
- 可以直接删除某个分区,方便清除历史数据;(比如按年来划分,一次删除某一年的数据);

但是分区表有很多限制, 以至于现在大部分公司都会规定**不允许在线上业务使用分区表**
- 分区必须包含主键与唯一键;
- 如果不能利用索引,则会访问所有分区;
- 只能单机使用;
- DDL操作影响大;
- 所有分区公用MDL锁;
- DBA需要持续维护分区;
- 分区表的性能略有下降、可能存在潜在bug;


## 了解TiDB吗?讲一讲TiDB相关特性?
TiDB解决了mysql摆脱不了的问题:从底层实现负载均衡;
1. 高度兼容mysql;mysql集群可以通过工具实时迁移到TiDB,TiDB也可以作为从库挂载到mysql主从架构中;
2. 分布式ACID事务;
3. 水平弹性扩展,可以同时扩展计算能力和存储能力:server负责处理请求,可以无限扩展;TiKV负责存储数据,部署更多TiKV解决数据问题;
4. 金融级高可用:不是MS主从复制方案,而是基于raft来保证数据的强一致性.并且能故障自动恢复;


## 怎么查看mysql的连接数和进程数?
使用`show PROCESSLIST`可以查看MySQL的所有连接;使用`show global status like 'Thread%'`可以查看mysql的线程数配置;


## 慢查询是什么?
SQL的执行时间超过MySQL中`long_query_time`参数的值的时候，会被记录到慢查询SQL日志文件中


## 如何判断一个sql语句是否有性能问题?
1. 检查OS:
    - CPU 常用的监控命令有top、mpstat等，打开后须重点观察%usr和 %iowait这两列; 如果 % usr 使用率较高，可以进一步检查数据库中是否有大量的 SQL 在做计算操作；如果 % iowait 较高，可以检查数据库中是否发生了大批量的读取或写入操作，或者有慢 SQL 语句频繁使用磁盘临时表空间等情况。
    - 如果怀疑磁盘 IO 有瓶颈，可以通过 iostat、iotop 等命令观察磁盘的读写情况;
    - 内存则看是否开启SWAP,开启SWAP可能会导致mysql变慢;
    - 检查网卡是否跑满了,是否大量丢包;

2. 检查DB:
    ```sql
    #检查Thread running是否过高
    mysql> show global status like 'Threads_running';

    #检查processlist中的SQL运行状态
    mysql> show processlist;
    mysql> show full processlist;

    #检查InnoDB锁等待
    mysql> SELECT * FROM sys.innodb_lock_waits;

    #检查InnoDB死锁
    #也可以在MySQL error log中寻找死锁信息的日志
    mysql> show engine innodb status \G
    ```

3. 找到有性能问题的sql:    
    - 看慢查询日志; `Percona Toolkit`
    - 使用EXPLAIN检查语句执行计划与Profile分析开销;`set profiling=1;`


## in-memory与on-disk有什么区别?讲讲你对临时表的理解?
- in-memory和on-disk都是查询时生成的临时表,只不过一个存在内存中,不涉及io,一个存在磁盘中;
- 通常情况下，MySQL 会优先使用 in-memory 临时表，只有当 in-memory 临时表存储的数据超过 MySQL 的参数中配置的内存使用量时，才会转化为 on-disk 临时表。
- 临时表有外部与内部,外部是用户创建的`CREATE TEMPOPARY TABLE`只对该用户可见,随着用户退出而删除;内部临时表是sql执行时自动创建的,只有在EXPLAIN的EXTRA里`Using tempopary`或者监控status,或者磁盘tmp table体积变大时才能发现;

- MySQL 会在以下 SQL 场景中触发临时表的使用：
    - UNION 子句
    - 派生表
    - 子查询和 SEMI JOIN
    - 包含 GROUP BY 和 ORDER BY 子句的语句
    - 包含 DISNTINCT 和 ORDER BY 子句的语句
    - 使用了 SQL_SMALL_RESULT 修饰符
    - 从同一个表中执行 INSERT…SELECT 语句
    - 多表 UPDATE 语句
    - GROUP_CONCAT 函数
    - COUNT (DISTINCT) 函数

- 还有一些情况，MySQL 会直接绕开 in-memory 临时表，使用 on-disk 临时表：
    - **表中包含 blob 或 text 的数据列**(这也是在开发规范中不建议使用blob和text字段的原因之一)
    - UNION 或 UNION ALL 子句中，SELECT 的列有大于 512 字节的

- 没办法避免使用临时表时,优化办法:
    - 给 GROUP BY 或 ORDER BY 的列上创建索引
    - 使用 UNION ALL 代替 UNION，因为 UNION 会对结果集进行排重
    - 分拆大字段，避免 on-disk 临时表的运行
    - 在查询中添加更多的过滤条件减小结果集的大小
    - 重写查询语句
    - 分段取出数据集
    - 如果 GROUP BY 不需要排序，加入 ORDER BY NULL 子句
    - 适当调大 in-memory 临时表的参数 "tmp_table_size"

- 建议在程序开发的过程中，尽量给高频使用的 GROUP BY、ORDER BY 等子句设计好索引，消除 Using temporary 和 Using filesort 的情况。


## 大文本数据如何设计字段?哪些引擎支持全文索引?讲一讲全文索引的实现方式;



# 事务与锁
## Mysql有哪些锁?
- 按照粒度划分: 行锁(开销大、并发高),表锁(开销小、并发低); (BDB引擎还有个页锁)
- 按级别分: 
    - 共享锁(S, share lock, 读锁、行锁): `select ... lock in share mode`, 其他用户可读不可写,其他用户只能加共享锁不能加排他锁;
    - 排他锁(X, Exclusive lock, 写锁、行锁): `select ... for update`,其他用户会阻塞;

    - 意向锁(Intention Lock, 表锁): 分为意向共享锁(IS)和意向排他锁(IX). 意向锁是InnoDB自动加的，不需要用户干预.因为S和X锁都只针对记录，而对于一些操作如alter table仅仅想知道这种表当前有没有数据被修改，所以为了处理这类操作引入了意向锁;

查看锁的情况: 
```sql
select * from information_schema.innodb_trx;--当前未提交事务的状态
select * from information_schema.innodb_locks;--当前正在争夺的锁
select * from information_schema.innodb_lock_waits;--当前等待的锁
```

## Mysql怎样加锁、隐式、显式（或者说，由谁决定加锁）
> see: 高性能mysql 附录E 锁的调试
*不同隔离级别加锁情况不同*
1. select不加任何锁,除非是serializable串行化隔离级别;
2. UPDATE、DELETE和INSERT以及`SELECT ... FOR UPDATE`语句加IX和X锁;
3. `SELECT ... LOCK IN SHARE MODE`,加S锁;

> see [详细加锁场景分析](./mysql-lock.md)

结论: 
显式锁, 隐式锁: 例如`select * ... for update`,这就是显式加锁;隐式加锁则是在索引记录逻辑上有x-lock,但实际内存对象中并不含有这个锁的信息;例如上面的详细加锁情况分析,当session1进行一次update不提交时(`set autocommit=0`),会对数据主键隐式加锁,此时执行`select * from information_schema.innodb_locks`查询不到锁的信息;但是当session2对该行数据进行更新操作时,发现对应的事务id处于活跃状态,因此session2会被阻塞,session2会为session1创建一条记录锁(隐式转显式),然后将自己放入等待队列中;此时查看`innodb_locks`可以看到两个事务对应的锁.


## update set a=1 from table where a=2 会加锁吗?怎么加的?会锁表吗?

根据隔离级别和字段不同情况不同,这里只谈隔离级别是可重复读的情况:
- a=2字段不是索引: 对所有数据主键加X锁,并且在记录的缝隙之间加GAP锁防止新记录插入导致幻读;
- a=2字段是普通索引: 对满足条件的记录加X锁+GAP锁,对应主键加X锁;防止幻读;
- a=2字段是唯一索引: 对满足条件的唯一索引+主键加X锁;
- a=2字段是主键: 对满足条件的主键加X锁;
- a=1是索引字段: 对该索引加锁;


## for update? 与 lock in share mode的区别
for update是IX锁(意向排它锁)，即在符合条件的rows上都加了排它锁，其他session也就无法在这些记录上添加任何的S锁或X锁。如果不存在一致性非锁定读的话，那么其他session是无法读取和修改这些记录的，但是innodb有非锁定读(快照读并不需要加锁)，for update之后并不会阻塞其他session的快照读取操作，除了select ...lock in share mode和select ... for update这种显示加锁的查询操作。

lock in share mode是IS锁(意向共享锁)，即在符合条件的rows上都加了共享锁，这样的话，其他session可以读取这些记录，也可以继续添加IS锁，但是无法修改这些记录直到你这个加锁的session执行完成(否则直接锁等待超时)。 

## 事务并发写的问题?
事务A对某行update操作会加锁,加锁的过程要分有索引和无索引两种情况,如:
```sql
update user set age=11 where id = 1
```
id 是这张表的主键，是有索引的情况，那么 MySQL 直接就在索引数中找到了这行数据，然后干净利落的加上行锁就可以了。
而下面这条语句
```sql
update user set age=11 where age=10
```
表中并没有为age字段设置索引，所以MySQL无法直接定位到这行数据。那MySQL会为这张表中所有行加行锁。在加上行锁后，MySQL 会进行一遍过滤，发现不满足的行就释放锁，最终只留下符合条件的行。虽然最终只为符合条件的行加了锁，但是这一锁一释放的过程对性能也是影响极大的。所以如果是大表的话，建议合理设计索引，如果真的出现这种情况，那很难保证并发度。


# 索引
## 聚簇索引相对于普通B+索引的优点?
叶子结点上保存了数据,可以直接取出来,不需要回表操作;

## B+树索引原理、为什么使用B+树而不使用红黑树，B+树为什么比红黑树快? 为什么是B+而不是平衡二叉树? 
B+树是多叉树，深度更小，B+树可以对叶子节点进行顺序遍历，B+树能够更好地利用磁盘扇区；

1. 对于磁盘的读取应该尽可能的减少IO次数。而红黑树本身是一棵二叉树, 深度相对B树太大, 意味着IO次数会更多;

2. 根据局部性原理与磁盘预读特性,当一个数据被用到时，其附近的数据也通常会马上被使用,预读的长度一般为页的整倍数;

3. 每次新建结点时，直接申请一个页面的空间，这样可以保证一个结点的大小等于一个页面，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。

## 索引查找在Linux的磁盘上是怎么操作的? 
例如查找id=100的数据,b+树有三层,所以一共三次io:
1. 把根结点所在的磁盘块加载到内存,在内存中二分查找到100或者100节点所在区间;
2. 加载对应的第二层节点,继续在第二层结点二分查找,找到100或者100所在的区间;
3. 加载第三层结点,找到100对应的行记录;


## myisam的索引结构，innodb的索引结构，innodb为什么必须要有主键索引?
myISAM索引是非聚集索引,B+树实现,在叶子结点保存了行地址;innodb是聚集索引,同样是B+树实现,但是在叶子结点保存了整行数据;

聚集索引的优点:
1. 聚集索引主键访问速度更快;
2. 如果能覆盖索引,则可以使用普通索引上主键的值,无需回表;

缺点:
1. 插入数据的速度严重依赖插入顺序;
2. 更新主键的代价会比较高。和插入数据时的问题一样，可能会出现 “页分裂” 使得性能变差;
3. 通过二级索引查找数据时需要两次IO;

主键具有唯一性,而且我们一般规范必须要自增主键,这样设计数据的访问速度会快很多;因为自增唯一的主键,在每次新增记录时直接写在b+树的尾部,只需要对一个页进行操作;(如果是不规则的插入,会导致*页的分裂*,要操作3个页);innodb所有数据保存根据主键生成的B+树上,所以必须要有主键索引;

如果没设计主键,innodb会找到第一个具有唯一性的索引作为主键,如果没有,则创建一个隐藏的row_id作为主键;


## 添加索引，为什么可以减少io操作?
没有索引的情况下,需要走全表扫描;有索引

## innodb各种索引的时间复杂度?
B+tree: 插入删除都是O(1)的时间;查找是O(logN) (以M阶为底,N代表)

## 什么是联合索引与列选择性?



## 现有一个新的查询场景, 要怎么解决? 1. 假如要查 A in () AND B in (),怎么建索引? 2. MySQL 是怎么利用索引的? 3. 假如查询 A in (), MySQL 是针对 N 个值分别查一次索引, 还是有更好的操作?
只给选择性高的一列建索引，这里因为两个都是范围查询所以另一个是走不到索引的（这里答的不好，其实也可以建联合索引然后用 （A,B) in ((1,2),(3,4)) 的方式去查）

先走一个非聚簇索引，查询出行数据后再用另一列回表做筛选

不知道，有了解的同学可以留言 (补充, @BillyLu 贴出了文档 equality-range-optimization, 大意是对非唯一索引 MySQL 会使用 index dive 的方式估算这个 range index 涉及的行数, 结合where optimization 中说明的在走 index 时假如涉及行数过多会走 full table scan, 那么假如 estimation 认为这次 IN 不够好, 是会走全表扫描的. 不知道除此之外, 面试官还有没有想考察的点)



## 联合索引的问题，A,B,C 三个字段，建立联合索引，列出了几种查询组合判断是否能命中索引
这个相对基础点了，所以直接给出了答案
面试官接着问了有一句总结出来描述这种索引顺序的总结话语是什么，这个想了下，好像没看到过
接着问了为什么查询必须按照索引的顺序
之前看《 Mysql 技术内幕：Innodb 存储引擎》时有提到这块，不过印象比较模糊了，同时这部分内容恰巧没有做笔记，所以只能根据对 B+树的理解给出一个解释
面试官没有明确的表示
（后面再回去看那本书，里面的解释是联合索引是一个多键值的 B+树）

## 联合索引中的字段顺序会产生什么影响

最左优先原则：要想SQL执行的时候能够用到联合索引，那么联合索引中的第一个字段一定要在where语句中，并且不能让该字段参与任何运算

## 什么情况下需要建索引，什么情况下可以不建

首先，要弄清楚[MySQL的数据查询原理](https://github.com/dooonabe/no-class-is-an-island/blob/master/article/Database/mysql.md)：InnoDB使用primary key通过clustered index(主索引)定位到完整的记录，每个secondary index(二级索引)都会包含primary key，所以无论是使用什么类型的索引，都是先查找符合条件的primary key列表。

那么如果查询语句的查询条件仅用到primary key，那么就不需要增加索引，此外如果查询条件的字段是仅包含两三个值的枚举类型，也是不需要增加索引。

## select * from t where a=? and b>? order by c limit 0,100 如何加索引

如果是我建的话 index （ a,b,c ）
根据 ab 查询到的数据，已经把 c 进行了排序了。。。
这个你理解有问题，他是考察你的最左匹配原则 正确答案应该是 acb 或者 cab.
我最近看的时候说加了范围之后后面查询不走索引，自己又试了一下发现也走，不明所以
是这样的 范围会用到一部分 但是接下来绝对会用到了。
首先 explain 的时候要避免 type=all 和 filesort 这两个出现
比如条件是 a>10 b=5 我索引弄成 a,b 也是能用到 a 这个部分的 但是 b 就用不到了
但是如果索引是 b,a 就会完全用到索引。
另外就是 order by 这个
如果你 select c order by c 索引是 c 开头 是可以用的上的
但是 select * order by c 这就不行了
所以这道题是有陷阱的，你要考虑到表中是否是只有 abc 三个字段 那么答案是唯一的 cab
否则就是 ab。也就是说我之前也说的不对。
这道题表面是考最左匹配 其实也包含了聚簇索引相关知识。


# 偏运维/分布式

## mysql主从怎么实现?有什么细节或者常见问题?

    // todo

## mysql怎么达到分布式一致性

    // todo

## mysql主从的时候有没有遇到过主从延迟同步的情况？是怎么解决的？
> 高性能mysql 10.7.14 过大的复制延迟
主从同步流程:
1. 在master机器上的操作:

    当master上的数据发生变化时，该事件变化会按照顺序写入bin-log中。当slave链接到master的时候，master机器会为slave开启binlog dump线程。当master的binlog发生变化的时候，bin-log dump线程会通知slave，并将相应的binlog内容发送给slave。

2. 在slave机器上操作:

    当主从同步开启的时候，slave上会创建两个线程：I\O线程。该线程连接到master机器，master机器上的binlog dump 线程会将binlog的内容发送给该I\O线程。该I/O线程接收到binlog内容后，再将内容写入到本地的relay log；sql线程。该线程读取到I/O线程写入的ralay log。并且根据relay log的内容对slave数据库做相应的操作。

主从延迟同步问题发现:(命令`show slave status`)一般来说,主库binlog是顺序写(效率高),slave的Slave_IO_Runing线程去主库取日志(效率高),但是在IO线程取完binlog开始实施,DML和DDL的操作是随机的(效率慢,因为需要磁盘寻道),还有可能与slave的其他查询发生锁争用.一个DDL执行10分钟,后面所有的DDL都得卡住.(而且master的ddl是可以并发的,而IO线程同步操作是单线程的).当主库的TPS并发较高时，产生的DDL数量超过slave一个sql线程所能承受的范围，那么延时就产生了，当然还有就是可能与slave的大型query语句产生了锁等待。

解决方法:
- 架构方面: **最好的办法是在设计程序时能够容忍出现延迟**(例如原神抽卡记录半个小时才更新).读写分离缓解主库压力、读做redis/memecache缓存,缓解读压力;
- 硬件方面: 升级cpu、升级磁盘阵列、保证主从在同一个交换机下,网速足够快;
- 主从同步加速: 禁用从库的一些配置(但是如果要将从库提升为主库,这些配置记得修改回来)
- 具体情况具体分析: 
    1. 不要重复写操作代价高的部分: 例如一个超大表的`update group by`操作,这个操作在主库以及每个从库都要执行一遍,从而导致延迟.解决办法有:拆分优化这个sql,尽量不使用group by;或者准备一个从库专门运行这个sql,将结果用`load data infile`快速载入主库中;
    2. 同步的瓶颈通常出现在某些表上,如果app是这些表的唯一更新源(该表对其他表没有依赖),可以考虑在复制之外单独处理这些表;