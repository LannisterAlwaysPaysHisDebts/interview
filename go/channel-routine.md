# 协程问题
1. 进程、线程、协程的区别. 面试官提示没有提到线程的有内核态的切换，go程只在用户态调度。
    简而言之,一个程序至少有一个进程,一个进程至少有一个线程.
    线程的划分尺度小于进程，使得多线程程序的并发性高。
    另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
    线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
    从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。


2. 怎么实现进程之间和线程之间的同步
    进程
    信号量：用信号量及PV操作来实现进程的同步和互斥。
    管程：将共享变量和对它们的操作集中在一个模块中，操作系统或并发程序就由这样的模块构成。这样模块之间联系清晰，便于维护和修改，易于保证正确性。

    线程
    临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。
        优点：保证在某一时刻只有一个线程能访问数据的简便办法。
        缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。
    互斥量:为协调共同对一个共享资源的单独访问而设计的。 
        优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。
        缺点：使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。
    信号量：为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了。
        优点：适用于对Socket（套接字）程序中线程的同步。
        缺点：
            1. 信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的弱点；
            2. 信号量机制功能强大，但使用时对信号量的操作分散， 而且难以控制，读写和维护都很困难，加重了程序员的编码负担；
            3. 核心操作P-V分散在各用户程序的代码中，不易控制和管理，一旦错误，后果严重，且不易发现和纠正。
    事件：用来通知线程有一些事件已发生，从而启动后继任务的开始。
        优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作。
        缺点：


3. 进程有哪几种状态，它们之间互相是怎么转换的
    就绪： 当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。
    执行：当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。
    阻塞：正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。

4. 对go routine的理解, 讲一下go routine的实现方式

5. 什么是协程泄露(Goroutine Leak)？

6.  Go 可以限制运行时操作系统线程的数量吗

7. goroutine 的调度是怎样的？

8. 进程虚拟空间分布，全局变量放哪里？

9. 操作系统内存管理？进程通讯，为什么共享存储区效率最高

10. ipc方式，共享存储区原理

11. 进程虚拟空间布局

12. 进程状态转换

13. 线程的栈在哪里分配

14. 多个线程读，一个线程写一个int32会不会有问题，int64呢（这里面试官后来说了要看数据总线的位数，32位的话写int32没问题，int64就有问题）

15. goroutine 和 kernel thread 之间是什么关系？

16. 进程与线程的区别

17. 堆与栈的区别

18. 内核态和用户态的划分与切换

19. 虚拟地址怎么映射到物理地址

20. 简述 IO 多路复用

21. 简述进程通信的各种方法

22. go程和线程有什么区别？
答：1 起一个go程大概只需要4kb的内存，起一个Java线程需要1.5MB的内存；go程的调度在用户态非常轻量，Java线程的切换成本比较高。接着问为啥成本比较高？因为Java线程的调度需要在用户态和内核态切换所以成本高？为啥在用户态和内核态之间切换调度成本比较高？简单说了下内核态和用户态的定义。接着问，还是没有明白为啥成本高？

23. goroutine 超时如何处理。

24. 问了 go 相关的问题，如果在一个 goroutine 里面发生的 panic，这个错误能捕捉吗
    之前验证过这个问题,直接回答了 goroutine 里面的 panic 只有在 goroutine 里面才能用 recover()捕捉，主协程无法捕捉，会导致整个进程崩溃
    然后问了框架是否应该在 goroutine 里自动进程捕捉，这个还没有认真考虑过，选了一个回答说不提供，这个回答面试官好像不满意

25. 另外一个 go 的问题，由于 go 协程无法预知执行顺序，如何控制 gorotine 的执行顺序
    回答说给每个 goroutine 传入一个编号，然后使用原子操作维持一个公共计数，计数与编号一直的协程才执行后续逻辑，执行完之后就给计数加一，触发下一个协程执行
    面试官说这个方式复杂了，有没有简单的办法，想了下没想到合适的方案



# channel问题
1. channel的实现方式; mutex和channel作并发控制你喜欢用哪个，哪个快，为什么? 自己设计一个mutex.

2. 向一个已经关闭了的channel写入数据会怎样? 怎么判断一个channel已经关闭?
    1. 对一个关闭的通道再发送值就会导致panic。
    2. 对一个关闭的通道进行接收会一直获取值直到通道为空。
    3. 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。
    4. 关闭一个已经关闭的通道会导致panic。

3. 简述channel, bufferd channel, unbuffed channel; 

4. channel的死锁与解决方法; 

5. 单项channel与双向channel; select多路监听

6. 为什么channel可以做到线程安全?

7. 如何用channel实现一个令牌桶？

8. 退出程序时怎么防止channel没有消费完

9. 用channel实现定时器？（实际上是两个协程同步）

10. 关于channel的特性，下面说法正确的是（）
    A. 给一个 nil channel 发送数据，造成永远阻塞
    B. 从一个 nil channel 接收数据，造成永远阻塞
    C. 给一个已经关闭的 channel 发送数据，引起 panic
    D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值


## answer

10. 关于channel的特性，下面说法正确的是（）
    ABCD

