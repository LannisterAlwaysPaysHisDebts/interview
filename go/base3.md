# append追加
### 类型
#### array
数组在内存中都是一连串的内存空间，通过指向数组开头的指针、元素的数量以及元素类型占的空间大小表示数组。
- Elem: 元素类型
- Bound: 数组大小

####  slice
- 结构：
  - Data: 指向数组的指针
  - Len: 当前切片的长度
  - Cap: 当前切片的容量

#####  扩容流程
- 1. 判断新容量的大小

	- 1. 如果期望容量大于当前容量的两倍就会使用期望容量；
	- 2. 如果当前切片的长度小于 1024 就会将容量翻倍；
	- 3. 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；
	- 仅确定切片的大致容量, 还需要根据切片中的元素大小对齐内存

- 2. 内存对齐

	- 1. 当数组中元素所占的字节大小为1、8或者2的倍数时, 将待申请的内存向上取整(可以提高内存的分配效率并减少碎片)
	- 2. 在默认情况下，将目标容量和元素大小相乘得到占用的内存

- 例子：触发扩容arr切片并传入期望的新容量5，这时期望分配的内存大小为 40 字节；不过因为切片中的元素大小等于sys.PtrSize，所以运行时会调用 runtime.roundupsize 向上取整内存的大小到 48 字节，所以新切片的容量为 48 / 8 = 6

#### map
哈希表的每个桶都只能存储 8 个键值对，一旦当前哈希的某个桶超出 8 个，新的键值对就会存储到哈希的溢出桶中。随着键值对数量的增加，溢出桶的数量和哈希的装载因子也会逐渐升高，超过一定范围就会触发扩容，扩容会将桶的数量翻倍，元素再分配的过程也是在调用写操作时增量进行的，不会造成性能的瞬时巨大抖动

在一个性能比较好的哈希表中，每一个桶中都应该有 0~1 个元素，有时会有 2~3 个，很少会超过这个数量。计算哈希、定位桶和遍历链表三个过程是哈希表读写操作的主要开销

#####  结构
- hmap

	- count: 元素数量
	- B: 表示当前哈希表持有的 buckets 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 len(buckets) == 2^B
	- hash0: 哈希种子
	- oldbuckets:是哈希在扩容时用于保存之前 buckets 的字段，它的大小是当前 buckets 的一半
	- buckets: []bmap
		- bmap结构： tophash: 存储了键的哈希的高 8 位，通过比较不同键的哈希的高 8 位可以减少访问键值对次数以提高性能

##### makemap
- 1. 当桶的数量小于 24 时，由于数据较少、使用溢出桶的可能性较低，会省略创建的过程以减少额外开销；
- 2. 当桶的数量多于 24 时，会额外创建 2^(𝐵−4)个溢出桶；

##### 读取, map[x]
- 1. 先通过哈希表设置的哈希函数、种子获取当前键对应的哈希
- 2. 拿到该键值对所在的桶序号和哈希高位的 8 位数字

##### 写入 map[k] = y
- 1. 先通过哈希表设置的哈希函数、种子获取当前键对应的哈希
- 2. 遍历比较桶中存储的 tophash 和键的哈希，如果找到了相同结果就会返回目标位置的地址
- 3. 当前桶已经满了则会创建新的桶；

##### 扩容
- 1. 装载因子已经超过 6.5
- 2. 哈希使用了太多溢出桶； 

	- 等量扩容

### channel
#### 结构体： hchan 

from:  src/runtime/chan.go


##### recvq/sendq: sudo g的队列

- sudo g: 当 g 遇到阻塞，或需要等待的场景时，会被打包成 sudog 这样一个结构。一个 g 可能被打包为多个 sudog 分别挂在不同的等待队列上:

##### 循环队列相关

- qcount: 元素计数
- dataqsiz: 环形队列的总大小
- buf: buffer channel的buf
- sendx/recvx： 发送/接收索引

#### 初始化： makechan

`makechan(t *chantype, size int) *hchan`

- 1. 如果当前 Channel 中不存在缓冲区，那么就只会为chan分配一段内存空间；

- 2. 如果当前 Channel 中存储的类型不是指针类型，会为当前的 Channel 和底层的数组分配一块连续的内存空间；

- 3. 在默认情况下会单独为 runtime.hchan 和缓冲区分配内存

#### 发送数据: chansend

`chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool`

- 1. 如果当前ch的recvq上存在已经被阻塞的 g，那么会直接将数据发送给当前 g 并将其设置成下一个运行的 g；

- 2. 如果 ch 存在缓冲区并且其中还有空闲的容量，我们会直接将数据存储到缓冲区 sendx 所在的位置上；

- 3. 阻塞情况：当前g阻塞,创建sudog并将其加入ch.sendq队列中；

#### 接收数据: chanrecv

`chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool)`


- 1. 如果 ch 为空，那么会直接gopark 挂起当前g；(nil ch)

- 2. 如果ch已经关闭并且缓冲区没有任何数据，会直接返回；

- 3. 如果ch的 sendq 队列中存在挂起的 g，会将 recvx 索引所在的数据拷贝到接收变量所在的内存空间上并将 sendq 队列中g的数据拷贝到缓冲区；

- 4. 如果ch的缓冲区中包含数据，那么直接读取recvx索引对应的数据；

- 5. 阻塞情况，将接收者打包成sudog并加入recvq中；

#### 关闭channel: closechan

##### 主要工作是清除两个阻塞队列

- 1. 如果recvq不为空，则拿到所有的sudog；

- 2. 如果sendq不为空，则拿到所有阻塞的sender的sudog;注意这种情况很容易造成panic，因为激活sender可能会往已经close的ch里面写数据;

- 拿到所有sudog, 全部唤醒；

#### 使用make初始化

##### typecheck1()里判断初始化类型为TCHAN

- OMAKE转换为OMAKECHAN，初始化chan

##### GMP

#### 版本更新

##### 1. 1版本： 任务窃取调度器

- 不同的处理器通过工作窃取对任务进行再分配实现任务的平衡

##### 1.2-1.13版本: 基于协作的抢占式调度器

- 问题

	- 1. 某些 g 长时间占用线程，造成其它 g 饥饿
	- 2. 垃圾回收需要暂停整个程序

##### 1.14： 基于信号的抢占式调度器 

- 垃圾回收与扫描栈时会触发抢占调度

#### 结构

##### G: 协程

- G的状态

	- 等待中：g正在等待某些条件满足，例如：系统调用结束等，包括 _Gwaiting、_Gsyscall 和 _Gpreempted 几个状态；
	- 可运行：g 已经准备就绪，可以在线程运行，如果当前程序中有非常多的 g，每个 g 就可能会等待更多的时间，即 _Grunnable；
	- 运行中：Goroutine 正在某个线程上运行，即 _Grunning；

##### M：线程

- 调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 GOMAXPROCS 个活跃线程能够正常运行
- 结构

	- curg: 是在当前线程上运行的用户 Goroutine，
	- g0: 是一个运行时中比较特殊的 Goroutine，它会深度参与运行时的调度过程，包括 Goroutine 的创建、大内存分配和 CGO 函数的执行

##### P：G与M的中间层，本地调度器

- 作用

	- 1. 提供线程需要的上下文环境
	- 2. 负责调度线程上的等待队列

#### 运行流程

##### 1. 程序启动，获得m0

##### 2. 创建g

- 1. 获取或者创建新的g结构体
- 2. 将参数写入g栈中

##### 3. 运行队列

- 1. next=true, g作为下一个处理器执行的任务
- 2. next=false,写入本地队列
- 3. 本地队列满了，会将本地队列的一部分加上待运行的g一起加入到全局队列

##### 4. 寻找g

- 1. 当全局运行队列中有待执行的g时，调用函数有一定几率从全局队列中查找g
- 2. 从本地队列中拿g
- 3.从全局队列中拿g
- 4. 从网络轮询器中看有没有g等待运行
- 5. 从其他p处窃取g

##### 5. 触发调度

- 1. 主动挂起

	- gopark: 暂停g，g不会返回运行队列; 等待调用goready唤醒

- 2. 系统调用
- 3. 协作式调用
- 4. 系统监控

### 网络io

#### 网络轮询器

- 所有的文件 I/O、网络 I/O 和计时器都是由网络轮询器管理的，它是 Go 语言运行时重要的组成部分。

- 网络轮询器并不是由运行时中的某一个线程独立运行的，运行时的调度器和系统调用都会通过 runtime.netpoll 与网络轮询器交换消息，获取待执行的 g 列表，并将待执行的 g 加入运行队列等待处理。

##### sysmon直接运行在线程上，所以toRun的g会被直接放到全局的 runq上

#### go实现的多路复用io

- 1. src/runtime/netpoll_epoll.go， linux默认使用epoll

- 2. 其他：src/runtime/netpoll_*.go

#### 通用结构体

##### pollCache

- lock
- pollDesc

	- link *pollDesc: 下一个pollDesc， pollDesc整体是链表结构
	- rseq/wseq: 表示文件描述符被重用或者计时器被重置
	- rg/wg: 表示二进制的信号量，可能为 pdReady、pdWait、{等待文件描述符可读或者可写的 g} 以及 nil；
	- rd/wd: 等待文件描述符可读或者可写的截止日期
	- rt/wt: 用于等待文件描述符的计时器

##### 结构体不在gc范围内，只能被epoll等模块引用

#### 多路复用

##### 初始化

- 1. 调用 epollcreate1 创建一个新的 epoll 文件描述符fd
- 2. 创建一个用于通信的管道: 提供了中断多路复用等待fd中事件的方法
- 3. 使用 epollctl 将用于读取数据的文件描述符打包成 epollevent 事件加入监听

##### 轮询事件

- 调用epollctl向全局的轮询fd中加入新的轮询事件监听fd的可读和可写状态

##### 事件循环

- 等待事件

	- g在fd上执行读写操作，发现不可读写，会进入等待状态，调用gopark主动让出线程

- 轮询等待

	- 1. 计算系统调用需要等待的时间
	- 2. 调用epollwait等待可读或者可写事件的发生
	- 3. 在循环中依次处理epollevent事件

##### 截止日期

- 截止日期小于0，直接唤醒对应g，g 在被唤醒之后会意识到当前的 I/O 操作已经超时，可以根据需要选择重试请求或者中止调用。

### 内存分配

#### 版本

##### 1.11以前是线性内存分配

- 定义三个虚拟内存区
- 1. span占512MB，存储指向内存管理单元的指针
- 2. bitma占16GB，用来标示arena哪些地址保存了对象
- 3. arena占512GB，是真正的堆区，8KB占一页，存储了堆上的初始化对象
- 因此1.11以前Go的内存最大只支持512GB

##### 1.11以后实现了稀疏内存分配

- 突破512GB的限制

#### 分配方法

##### 线性分配

- 线性分配内存，数据清除，数据占用的内存无法再次分配，需要有很好的回收算法

##### 空闲链表分配

- 将内存分块划分成若干节点，相互组成链表
- go是这种分配方法

#### 内存管理组件

##### 内存管理单元: mspan

- 字段

	- next
	- prev

		- 与其他单元组成双链表

	- startAddr: 起始地址
	- npages: 页数, 每个页都是8kb

- 当结构体管理的内存不足时，会以页为单位向堆申请内存：

##### 线程缓存：mcache

- 字段 alloc，数组，保存了若干mspan

##### 中心缓存:mcentral

- 访问需要加互斥锁

##### 页堆: mheap

- 保存了mcentral数组
- 保存了管理堆区的arenas

	- 平台不同大小不同，一般arenas管理空间大小为64MB

#### 内存分配

##### 函数newobject分配内存，mallocgc分配指定大小的空间

##### 三种对象

- 微对象： (0, 16byte)

	- 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存

- 小对象 [16B, 32KB]

	- 依次尝试使用线程缓存、中心缓存和堆分配内存

- 大对象 (32KB, +∞)

	- 直接在堆上分配内存

### GC
> 引用类型的全局变量内存分配在堆上，值类型的全局变量分配在栈上
局部变量内存分配可能在栈上也可能在堆上

常见的几种逃逸:  指针逃逸、interface逃逸、栈空间不足、返回闭包；

#### gc工作原理
Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术

标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：
- 标记阶段: 从根对象出发查找并标记root中所有存活的对象；
- 清除阶段: 遍历root中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。

标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少STW的时间，Go语言采用了三色标记法。

三色标记算法将程序中的对象分成白色、黑色和灰色三类。
- 白色：不确定对象。
- 灰色：存活对象，子对象待处理。
- 黑色：存活对象。

标记开始时，所有对象加入白色集合（这一步需STW）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。

gc过程中，Go使用了内存屏障技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。

##### gc四阶段
1. Stack scan：收集根对象（全局变量，和G stack），开启写屏障。全局变量、开启写屏障需要STW，G stack只需要停止该G就好，时间比较少。
2. Mark: 扫描所有根对象, 和根对象可以到达的所有对象, 标记它们不被回收
3. Mark Termination: 完成标记工作, 重新扫描部分根对象(要求STW),关闭写屏障.
4. Sweep: 按标记结果清扫span(并发)

