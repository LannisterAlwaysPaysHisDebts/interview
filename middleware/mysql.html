<!DOCTYPE html>
<html>
<head>
<title>mysql.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E5%BC%95%E6%93%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">引擎,隔离级别</h1>
<h2 id="innodbmyisam%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%84%E8%87%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95">InnoDB、MyISAM的区别?各自使用的索引?</h2>
<ol>
<li>InnoDB支持事务，MyISAM 不支持事务;</li>
<li>InnoDB支持外键，而MyISAM不支持;</li>
<li>InnoDB是聚簇索引，MyISAM是非聚簇索引。</li>
<li>InnoDB不保存表的具体行数，执行<code>select count(*) from table</code>时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>InnoDB最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。</li>
<li>MyISAM在备份的时候需要对表加锁来保证数据的一致性,InnoDB支持热备份,通过事务和MVCC</li>
<li>InnoDB在5.7.8之后支持JSON数据类型了;</li>
</ol>
<p>由于InnoDB的发展与日益强大，目前在绝大多数场景下选择这一种存储引擎即可，除了一些极特别的应用场景，其实没有理由再去选择其他的存储引擎。</p>
<h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88innodb%E6%9F%A5%E8%AF%A2count%E4%BC%9A%E5%BE%88%E6%85%A2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%92%8Cmyisam%E4%B8%80%E6%A0%B7%E5%85%A8%E5%B1%80%E5%AD%98%E5%82%A8%E4%B8%80%E4%B8%AAcount%E6%95%B0">为什么innodb查询count(*)会很慢? 为什么不和MyISAM一样全局存储一个count数?</h2>
<ul>
<li>因为innodb中的MVCC给每行数据保存了两个额外的字段:创建版本号与删除版本号;</li>
<li>由于每一行数据都需要判断自己是否对这个事务可见，所以InnoDB就必须把数据一行一行的全部读出，然后进行判断。版本号小于当前事务的，或者没有行删除标记的，才会被纳入统计的表的总行数。</li>
</ul>
<h2 id="%E7%AE%80%E8%BF%B0%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB">简述关系型数据库与非关系形数据库的区别与联系</h2>
<ul>
<li>存储方式: 关系型数据库是表格式的，数据存储在表的行和列中;Nosql数据库是大块的组合在一起,通常存储在数据集中，就像文档、键值对或者图结构;</li>
<li>存储结构: 关系型数据库是结构化数据,数据表都预先定义了结构;Nosql数据库基于动态结构，使用与非结构化数据。</li>
<li>存储规范: 关系型数据库的数据存储为了更高的规范性，把数据分割为最小的关系表以避免重复，获得精简的空间利用。而Nosql数据存储在平面数据集中，数据经常可能会重复。单个数据库很少被分隔开，而是存储成了一个整体，这样整块数据更加便于读写;</li>
<li>存储扩展: 关系型数据库一般是纵向扩展,也就是说想要提高处理能力，要使用速度更快的计算机;而Nosql数据库是横向扩展的，它的存储天然就是分布式的，可以通过给资源池添加更多的普通数据库服务器来分担负载。</li>
<li>查询方式: 关系型数据库通过结构化查询语言来操作数据库(sql),而Nosql查询以块为单元操作数据，使用的是非结构化查询语言;关系型数据库使用预定义优化方式（比如索引）来加快查询操作，而Nosql更简单更精确的数据访问模式。</li>
<li>事务: 关系型数据库遵循ACID（原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)）规则、Nosql数据库遵循BASE（基本可用（Basically Availble）、软/柔性事务（Soft-state ）、最终一致性（Eventual Consistency））原则;关系型数据库支持对事务原子性细粒度控制，并且易于回滚事务。而Nosql数据库是在CAP（一致性、可用性、分区容忍度）中任选两项，因为基于节点的分布式系统中，很难全部满足，所以对事务的支持不是很好，虽然也可以使用事务，但是并不是Nosql的闪光点。</li>
</ul>
<h2 id="%E7%AE%80%E8%BF%B0acid">简述ACID</h2>
<ul>
<li>原子性(Atomicity): 事务是一个不可再分割的工作单元;</li>
<li>一致性(Consistency): 事务开始之前和事务结束以后，数据库的完整性约束(比如唯一索引)没有被破坏;</li>
<li>隔离性(Isolation): 多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果;</li>
<li>持久性(Durability): 在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚;</li>
</ul>
<h2 id="%E8%AE%B2%E4%B8%80%E8%AE%B2mysql%E7%9A%84%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF">讲一讲mysql的优化思路?</h2>
<ul>
<li>选择合理的数据库引擎 =&gt; innodb</li>
<li>选择合适的字段类型 =&gt; 比如枚举值, 很多人建表都是<code>int(1)</code>, 其实int里面的1指的不是长度为1,而是显示宽度;最佳实践应该是设置为tinyint类型;</li>
<li>部分字段建立索引 =&gt; 常用where字段建立索引、where group by/order by建立联合索引等等;</li>
<li>主从复制读写分离;</li>
<li>分库分表;</li>
</ul>
<h2 id="%E8%AE%B2%E4%B8%80%E8%AE%B2sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF">讲一讲sql语句的优化思路?</h2>
<p>基本思路是基于代价估算模型对SQL语句进行调优，找出代价最小的那个执行方式。扫描算法多表连接算法方面mysql的查询优化器已经做的足够好了,不需要我们干预;我们重点优化<strong>数据扫描</strong>和<strong>索引</strong></p>
<h2 id="%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90sql%E6%89%A7%E8%A1%8C%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0">如何分析SQL执行慢的原因</h2>
<p>流程:</p>
<ol>
<li>是否存在周期波动? 是=&gt; 加缓存、更改缓存失效策略;</li>
<li>开启慢查询, <code>EXPLAIN SHOW PROFILING</code>, 如果:
<ol>
<li>sql等待时间长 =&gt; 调优服务器参数;</li>
<li>sql执行时间长 =&gt; 索引设计优化;JOIN表过多?数据表设计优化;</li>
<li>如果1、2都没有解决问题,考虑是否是sql查询到达了服务器瓶颈 =&gt; 1. 读写分离; 2. 分库分表(垂直分库、垂直分表、水平分表)</li>
</ol>
</li>
</ol>
<h2 id="%E4%B8%80%E6%9D%A1mysql%E6%95%B0%E6%8D%AE%E6%98%AF%E6%80%8E%E4%B9%88%E6%9F%A5%E5%87%BA%E6%9D%A5%E7%9A%84">一条mysql数据是怎么查出来的?</h2>
<p>一条sql语句在执行过程中需要经过连接器、分析器、优化器、执行器等，也有可能会经过查询缓存:</p>
<ul>
<li>连接器: 负责与客户端建立连接、获取权限、维持和管理连接</li>
<li>查询缓存: MySql拿到查询后，会先到查询缓存查看是否执行过这条语句;在MySql8.0之后去掉了查询缓存的功能。</li>
<li>分析器: 词法分析,识别出sql里的字符串分别是什么，“select”代表这是一条查询语句,T转换称“表T”;语法分析:根据词法分析的结果，判断该条sql是否满足MySql的语法</li>
<li>优化器: 优化器的作用在于选择最优的逻辑执行sql;</li>
<li>执行器: 在开始执行前，先判断你对表T是否有执行查询的权限;执行器根据表的引擎定义，调用该引擎提供的接口。</li>
</ul>
<p>// todo sql查询顺序</p>
<h2 id="innodb%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E5%88%86%E5%88%AB%E6%98%AF%E5%9C%A8%E5%93%AA%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%A7%A3%E5%86%B3%E7%9A%84%E5%B9%BB%E8%AF%BB%E8%A7%A3%E5%86%B3%E7%9A%84%E5%8E%9F%E7%90%86-gap-mvcc%E7%B4%A2%E5%BC%95%E7%A7%8D%E7%B1%BB%E5%92%8C%E5%8C%BA%E5%88%AB">innodb有哪些隔离级别?不可重复读和幻读分别是在哪个隔离级别解决的?幻读解决的原理, gap? mvcc索引种类和区别?</h2>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/117476959">MySQL事务隔离级别和实现原理</a></p>
</blockquote>
<p>在不同的隔离级别下，数据库通过MVCC和隔离级别，让事务之间并行操作遵循了某种规则，来保证单个事务内前后数据的一致性。</p>
<p>前置知识:</p>
<ul>
<li>脏读:指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了不一定最终存在的数据，这就是脏读。</li>
<li>可重复读:指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。通常针对数据更新（UPDATE）操作。</li>
<li>不可重复读:对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据更新（UPDATE）操作。</li>
<li>幻读:幻读是针对数据插入（INSERT）操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交（READ UNCOMMITTED）</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>读提交 （READ COMMITTED）</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读 （REPEATABLE READ）</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>串行化 （SERIALIZABLE）</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody>
</table>
<p>从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，<em>可重复读</em>是MySQL的默认级别。</p>
<p>GAP间隙锁: mysql底层通过间隙锁来解决可重复读级别下幻读的问题. 间隙锁实质是对索引的前后间隙上锁,不对索引本身上锁。根据检索条件向左寻找最靠近检索条件的记录值A，作为左区间，向右寻找最靠近检索条件的记录值B作为右区间，即锁定的间隙为（A，B）。</p>
<p>GAP防止:1. 防止间隙内有新数据被插入; 2. 防止已存在的数据，更新成间隙内的数;</p>
<p>GAP要求: where条件字段是整型主键;</p>
<p>MVCC:</p>
<ul>
<li>innodb有个版本号,每启动一次事务版本号都会增加;</li>
<li>在每行数据后面增加了两个字段: 创建时间与删除时间;</li>
<li>insert时创建时间设置为当前版本号;</li>
<li>delete时删除时间设置为当前版本号;</li>
<li>select时,只可查询到: 创建时间小于等于当前版本号的,并且删除时间为空或者大于当前版本号;</li>
<li>update时,插入一条新记录,并且原来行的删除时间记录为当前版本号;</li>
</ul>
<h2 id="%E6%9C%89%E7%94%A8%E8%BF%87mysql%E7%9A%84%E4%BB%80%E4%B9%88%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%90%97%E8%AE%B2%E4%B8%80%E4%B8%8B">有用过MySQL的什么高级特性吗?讲一下</h2>
<p>见高性能mysql第七章, 这里挑几个写一下:</p>
<ul>
<li>分区表: 生产环境不允许使用分区表;</li>
<li>视图: ?</li>
<li>外键约束: 生产环境不允许使用mysql层的外键约束,只能从代码上进行约束;</li>
<li>游标: ?</li>
<li>全文索引: ?</li>
<li>分布式XA事务: ?</li>
<li>查询缓存: ?</li>
</ul>
<h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89innodb">为什么选InnoDB?</h2>
<p>几乎所有公司用MySQL都用InnoDB，降低踩坑成本；</p>
<ol>
<li>支持事务;</li>
<li>支持行锁;</li>
<li>MVCC;</li>
<li>Next-Key锁解决幻读问题;</li>
<li>完整支持ACID;</li>
<li>一致性非锁定读;</li>
<li>支持热备, 开启一个事务即可;</li>
<li>支持json;</li>
<li>5.6以后支持online ddl</li>
</ol>
<h2 id="mysql%E8%AF%AD%E5%8F%A5%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B">mysql语句性能评测？</h2>
<blockquote>
<p>见 高性能mysql 附录EXPLAIN</p>
</blockquote>
<p>使用EXPLAIN(在5.6以后非select语句也能使用).比较重要的列有:</p>
<table>
<thead>
<tr>
<th style="text-align:left">列</th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">type</td>
<td>访问类型.const：表示通过索引一次就找到了;eq_ref：通过唯一索引扫描整个表;ref：非唯一性索引扫描;range：where语句中出现了bettween、&lt;、&gt;、in等的查询;index：index与ALL区别为index类型只遍历索引树。ALL: 全表扫描。</td>
</tr>
<tr>
<td style="text-align:left">key</td>
<td>MySQL实际采用哪个索引</td>
</tr>
<tr>
<td style="text-align:left">rows</td>
<td>查询优化器预估需要读取的行数</td>
</tr>
<tr>
<td style="text-align:left">Extra</td>
<td>Using index: 从索引中就可以查询到最终需要的信息，不需要再读取表;Using where ：表示优化器需要通过索引回表查询数据;Using temporary: 对查询结果排序时使用了临时表，常见于order by 和 group by;Using filesort: MySQL中无法利用索引完成的排序操作称为”文件排序”</td>
</tr>
</tbody>
</table>
<h2 id="%E4%BD%A0%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%80%E5%A4%A7%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8F%E7%BA%A7%E6%98%AF%E5%A4%9A%E5%B0%91-%E5%88%86%E8%A1%A8%E7%9A%84%E7%AD%96%E7%95%A5%E5%88%86%E8%A1%A8%E4%B8%8B%E7%9A%84%E5%88%A9%E5%BC%8A%E5%88%86%E8%A1%A8%E4%B8%8B%E4%B8%8D%E5%90%8C%E6%9F%A5%E8%AF%A2%E7%BB%B4%E5%BA%A6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E4%BD%A0%E5%AF%B9%E5%8F%8C%E5%90%91%E8%A1%A8%E7%9A%84%E7%90%86%E8%A7%A3">你处理过最大表的数据量级是多少? 分表的策略,分表下的利弊,分表下不同查询维度如何实现?以及你对双向表的理解?</h2>
<ul>
<li>
<p>上亿的数据: 消息表(后面做了归档)每天增量近百万; 百万数据: 商品表、推送日志表;</p>
</li>
<li>
<p>分表策略: 我们会评估是单表体积过大，还是某个db中的大表较多;</p>
<ul>
<li>如果是因为db中的大表较多，可以考虑垂直切分，根据业务将较大的db拆出去，或者将某个较大的db拆分成多个db。</li>
<li>如果是单表体积过大，需要做水平拆分，即将表的数据按某种规则切分成多张表，或多个库上的多张表。</li>
</ul>
</li>
</ul>
<p>分表了一个弊端，即数据冗余
然后说优势，减少单个表的索引大学，加快查询速度，多个表也可以支持并发插入
// todo</p>
<h2 id="%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84%E7%90%86%E8%A7%A3">谈谈你对分区表的理解?</h2>
<ul>
<li>在创建表的时候,使用<code>partition by</code>关键字来分区;</li>
<li>整体来看仍然是一个表,但是会分若干个idb文件存储,说明对业务是透明的;</li>
<li>可以直接删除某个分区,方便清除历史数据;(比如按年来划分,一次删除某一年的数据);</li>
</ul>
<p>但是分区表有很多限制, 以至于现在大部分公司都会规定<strong>不允许在线上业务使用分区表</strong></p>
<ul>
<li>分区必须包含主键与唯一键;</li>
<li>如果不能利用索引,则会访问所有分区;</li>
<li>只能单机使用;</li>
<li>DDL操作影响大;</li>
<li>所有分区公用MDL锁;</li>
<li>DBA需要持续维护分区;</li>
<li>分区表的性能略有下降、可能存在潜在bug;</li>
</ul>
<h2 id="%E4%BA%86%E8%A7%A3tidb%E5%90%97%E8%AE%B2%E4%B8%80%E8%AE%B2tidb%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7">了解TiDB吗?讲一讲TiDB相关特性?</h2>
<p>TiDB解决了mysql摆脱不了的问题:从底层实现负载均衡;</p>
<ol>
<li>高度兼容mysql;mysql集群可以通过工具实时迁移到TiDB,TiDB也可以作为从库挂载到mysql主从架构中;</li>
<li>分布式ACID事务;</li>
<li>水平弹性扩展,可以同时扩展计算能力和存储能力:server负责处理请求,可以无限扩展;TiKV负责存储数据,部署更多TiKV解决数据问题;</li>
<li>金融级高可用:不是MS主从复制方案,而是基于raft来保证数据的强一致性.并且能故障自动恢复;</li>
</ol>
<h2 id="%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8Bmysql%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%95%B0%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%95%B0">怎么查看mysql的连接数和进程数?</h2>
<p>使用<code>show PROCESSLIST</code>可以查看MySQL的所有连接;使用<code>show global status like 'Thread%'</code>可以查看mysql的线程数配置;</p>
<h2 id="%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%98%AF%E4%BB%80%E4%B9%88">慢查询是什么?</h2>
<p>SQL的执行时间超过MySQL中<code>long_query_time</code>参数的值的时候，会被记录到慢查询SQL日志文件中</p>
<h2 id="%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AAsql%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%90%A6%E6%9C%89%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98">如何判断一个sql语句是否有性能问题?</h2>
<ol>
<li>
<p>检查OS:</p>
<ul>
<li>CPU 常用的监控命令有top、mpstat等，打开后须重点观察%usr和 %iowait这两列; 如果 % usr 使用率较高，可以进一步检查数据库中是否有大量的 SQL 在做计算操作；如果 % iowait 较高，可以检查数据库中是否发生了大批量的读取或写入操作，或者有慢 SQL 语句频繁使用磁盘临时表空间等情况。</li>
<li>如果怀疑磁盘 IO 有瓶颈，可以通过 iostat、iotop 等命令观察磁盘的读写情况;</li>
<li>内存则看是否开启SWAP,开启SWAP可能会导致mysql变慢;</li>
<li>检查网卡是否跑满了,是否大量丢包;</li>
</ul>
</li>
<li>
<p>检查DB:</p>
<pre class="hljs"><code><div><span class="hljs-comment">#检查Thread running是否过高</span>
mysql&gt; <span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> <span class="hljs-keyword">status</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'Threads_running'</span>;

<span class="hljs-comment">#检查processlist中的SQL运行状态</span>
mysql&gt; <span class="hljs-keyword">show</span> <span class="hljs-keyword">processlist</span>;
mysql&gt; <span class="hljs-keyword">show</span> <span class="hljs-keyword">full</span> <span class="hljs-keyword">processlist</span>;

<span class="hljs-comment">#检查InnoDB锁等待</span>
mysql&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> sys.innodb_lock_waits;

<span class="hljs-comment">#检查InnoDB死锁</span>
<span class="hljs-comment">#也可以在MySQL error log中寻找死锁信息的日志</span>
mysql&gt; <span class="hljs-keyword">show</span> <span class="hljs-keyword">engine</span> <span class="hljs-keyword">innodb</span> <span class="hljs-keyword">status</span> \G
</div></code></pre>
</li>
<li>
<p>找到有性能问题的sql:</p>
<ul>
<li>看慢查询日志; <code>Percona Toolkit</code></li>
<li>使用EXPLAIN检查语句执行计划与Profile分析开销;<code>set profiling=1;</code></li>
</ul>
</li>
</ol>
<h2 id="in-memory%E4%B8%8Eon-disk%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E8%AE%B2%E8%AE%B2%E4%BD%A0%E5%AF%B9%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E7%90%86%E8%A7%A3">in-memory与on-disk有什么区别?讲讲你对临时表的理解?</h2>
<ul>
<li>
<p>in-memory和on-disk都是查询时生成的临时表,只不过一个存在内存中,不涉及io,一个存在磁盘中;</p>
</li>
<li>
<p>通常情况下，MySQL 会优先使用 in-memory 临时表，只有当 in-memory 临时表存储的数据超过 MySQL 的参数中配置的内存使用量时，才会转化为 on-disk 临时表。</p>
</li>
<li>
<p>临时表有外部与内部,外部是用户创建的<code>CREATE TEMPOPARY TABLE</code>只对该用户可见,随着用户退出而删除;内部临时表是sql执行时自动创建的,只有在EXPLAIN的EXTRA里<code>Using tempopary</code>或者监控status,或者磁盘tmp table体积变大时才能发现;</p>
</li>
<li>
<p>MySQL 会在以下 SQL 场景中触发临时表的使用：</p>
<ul>
<li>UNION 子句</li>
<li>派生表</li>
<li>子查询和 SEMI JOIN</li>
<li>包含 GROUP BY 和 ORDER BY 子句的语句</li>
<li>包含 DISNTINCT 和 ORDER BY 子句的语句</li>
<li>使用了 SQL_SMALL_RESULT 修饰符</li>
<li>从同一个表中执行 INSERT…SELECT 语句</li>
<li>多表 UPDATE 语句</li>
<li>GROUP_CONCAT 函数</li>
<li>COUNT (DISTINCT) 函数</li>
</ul>
</li>
<li>
<p>还有一些情况，MySQL 会直接绕开 in-memory 临时表，使用 on-disk 临时表：</p>
<ul>
<li><strong>表中包含 blob 或 text 的数据列</strong>(这也是在开发规范中不建议使用blob和text字段的原因之一)</li>
<li>UNION 或 UNION ALL 子句中，SELECT 的列有大于 512 字节的</li>
</ul>
</li>
<li>
<p>没办法避免使用临时表时,优化办法:</p>
<ul>
<li>给 GROUP BY 或 ORDER BY 的列上创建索引</li>
<li>使用 UNION ALL 代替 UNION，因为 UNION 会对结果集进行排重</li>
<li>分拆大字段，避免 on-disk 临时表的运行</li>
<li>在查询中添加更多的过滤条件减小结果集的大小</li>
<li>重写查询语句</li>
<li>分段取出数据集</li>
<li>如果 GROUP BY 不需要排序，加入 ORDER BY NULL 子句</li>
<li>适当调大 in-memory 临时表的参数 &quot;tmp_table_size&quot;</li>
</ul>
<blockquote>
<p>在MySQL 8.0版本之前，GROUP BY子句默认会使用隐式排序。显式指定ORDER BY NULL可以让MySQL在执行GROUP BY子句时不再强制排序，可以提升一部分性能。这算是个奇淫巧技，不用也可以。在MySQL 8.0版本之后，官方不再支持GROUP BY隐式排序，因此不再需要使用ORDER BY NULL这个语法;</p>
</blockquote>
</li>
<li>
<p>建议在程序开发的过程中，尽量给高频使用的 GROUP BY、ORDER BY 等子句设计好索引，消除 Using temporary 和 Using filesort 的情况。</p>
</li>
</ul>
<h2 id="%E5%A4%A7%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AD%97%E6%AE%B5%E5%93%AA%E4%BA%9B%E5%BC%95%E6%93%8E%E6%94%AF%E6%8C%81%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%E8%AE%B2%E4%B8%80%E8%AE%B2%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">大文本数据如何设计字段?哪些引擎支持全文索引?讲一讲全文索引的实现方式;</h2>
<p>// todo  innodb在5.6之后实现了全文索引,是基于单词来统计的;</p>
<h2 id="%E6%9C%89%E6%B2%A1%E6%9C%89%E9%81%87%E5%88%B0%E8%BF%87%E4%B8%BB%E9%94%AEid%E4%B8%8D%E8%BF%9E%E7%BB%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84">有没有遇到过主键id不连续的问题?怎么解决的?</h2>
<p>不连续的情况:</p>
<ol>
<li>master-master设置了步长; =&gt; 不影响</li>
<li>自增锁的问题: 事务申请了id,却主动回滚或者因为死锁而回滚; =&gt;  (公司业务没有对主键id必须连续的要求)以前查过这类问题,貌似可以写一个触发器在insert之后重置auto_increment的值?
<blockquote>
<p>在 MySQL 5.1.22 版本后，InnoDB 为了解决自增主键锁表的问题，引入了一个参数 innodb_autoinc_lock_mode。这个参数有 3 个可选的值：“0, 1, 2”：</p>
<ul>
<li>0：表锁的方式处理自增，所有类型的 INSERT 语句都使用 Auto-inc locking。</li>
<li>1：产生一个轻量锁，对于 simple insert 自增长值的产生使用互斥量对内存中的计数器进行累加操作，对于 bulk insert 则还是使用表锁的方式进行。</li>
<li>2：对所有的 insert-like 自增长值的产生使用互斥量机制完成，并发性能最高，并发插入可能导致自增值不连续。</li>
</ul>
<p>目前 MySQL 5.7 中默认使用参数配置 “2”。</p>
</blockquote>
</li>
<li>可能有delete的情况; =&gt; 软删除,不允许使用delete</li>
</ol>
<h1 id="%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81">事务与锁</h1>
<h2 id="mysql%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81">Mysql有哪些锁?</h2>
<ul>
<li>按照粒度划分: 行锁(开销大、并发高),表锁(开销小、并发低); (BDB引擎还有个页锁)</li>
<li>按级别分:
<ul>
<li>
<p>共享锁(S, share lock, 读锁、行锁): <code>select ... lock in share mode</code>, 其他用户可读不可写,其他用户只能加共享锁不能加排他锁;</p>
</li>
<li>
<p>排他锁(X, Exclusive lock, 写锁、行锁): <code>select ... for update</code>,其他用户会阻塞;</p>
</li>
<li>
<p>意向锁(Intention Lock, 表锁): 分为意向共享锁(IS)和意向排他锁(IX). 意向锁是InnoDB自动加的，不需要用户干预.因为S和X锁都只针对记录，而对于一些操作如alter table仅仅想知道这种表当前有没有数据被修改，所以为了处理这类操作引入了意向锁;</p>
</li>
</ul>
</li>
</ul>
<p>查看锁的情况:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> information_schema.innodb_trx;<span class="hljs-comment">--当前未提交事务的状态</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> information_schema.innodb_locks;<span class="hljs-comment">--当前正在争夺的锁</span>
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> information_schema.innodb_lock_waits;<span class="hljs-comment">--当前等待的锁</span>
</div></code></pre>
<h2 id="mysql%E6%80%8E%E6%A0%B7%E5%8A%A0%E9%94%81%E9%9A%90%E5%BC%8F%E6%98%BE%E5%BC%8F%E6%88%96%E8%80%85%E8%AF%B4%E7%94%B1%E8%B0%81%E5%86%B3%E5%AE%9A%E5%8A%A0%E9%94%81">Mysql怎样加锁、隐式、显式（或者说，由谁决定加锁）</h2>
<blockquote>
<p>see: 高性能mysql 附录E 锁的调试
<em>不同隔离级别加锁情况不同</em></p>
</blockquote>
<ol>
<li>select不加任何锁,除非是serializable串行化隔离级别;</li>
<li>UPDATE、DELETE和INSERT以及<code>SELECT ... FOR UPDATE</code>语句加IX和X锁;</li>
<li><code>SELECT ... LOCK IN SHARE MODE</code>,加S锁;</li>
</ol>
<blockquote>
<p>see <a href="./mysql-lock.md">详细加锁场景分析</a></p>
</blockquote>
<p>结论:
显式锁, 隐式锁: 例如<code>select * ... for update</code>,这就是显式加锁;隐式加锁则是在索引记录逻辑上有x-lock,但实际内存对象中并不含有这个锁的信息;例如上面的详细加锁情况分析,当session1进行一次update不提交时(<code>set autocommit=0</code>),会对数据主键隐式加锁,此时执行<code>select * from information_schema.innodb_locks</code>查询不到锁的信息;但是当session2对该行数据进行更新操作时,发现对应的事务id处于活跃状态,因此session2会被阻塞,session2会为session1创建一条记录锁(隐式转显式),然后将自己放入等待队列中;此时查看<code>innodb_locks</code>可以看到两个事务对应的锁.</p>
<h2 id="update-set-a1-from-table-where-a2-%E4%BC%9A%E5%8A%A0%E9%94%81%E5%90%97%E6%80%8E%E4%B9%88%E5%8A%A0%E7%9A%84%E4%BC%9A%E9%94%81%E8%A1%A8%E5%90%97">update set a=1 from table where a=2 会加锁吗?怎么加的?会锁表吗?</h2>
<p>根据隔离级别和字段不同情况不同,这里只谈隔离级别是可重复读的情况:</p>
<ul>
<li>a=2字段不是索引: 对所有数据主键加X锁,并且在记录的缝隙之间加GAP锁防止新记录插入导致幻读;</li>
<li>a=2字段是普通索引: 对满足条件的记录加X锁+GAP锁,对应主键加X锁;防止幻读;</li>
<li>a=2字段是唯一索引: 对满足条件的唯一索引+主键加X锁;</li>
<li>a=2字段是主键: 对满足条件的主键加X锁;</li>
<li>a=1是索引字段: 对该索引加锁;</li>
</ul>
<h2 id="for-update-%E4%B8%8E-lock-in-share-mode%E7%9A%84%E5%8C%BA%E5%88%AB">for update? 与 lock in share mode的区别</h2>
<p>for update是IX锁(意向排它锁)，即在符合条件的rows上都加了排它锁，其他session也就无法在这些记录上添加任何的S锁或X锁。如果不存在一致性非锁定读的话，那么其他session是无法读取和修改这些记录的，但是innodb有非锁定读(快照读并不需要加锁)，for update之后并不会阻塞其他session的快照读取操作，除了select ...lock in share mode和select ... for update这种显示加锁的查询操作。</p>
<p>lock in share mode是IS锁(意向共享锁)，即在符合条件的rows上都加了共享锁，这样的话，其他session可以读取这些记录，也可以继续添加IS锁，但是无法修改这些记录直到你这个加锁的session执行完成(否则直接锁等待超时)。</p>
<h2 id="%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%86%99%E7%9A%84%E9%97%AE%E9%A2%98">事务并发写的问题?</h2>
<p>事务A对某行update操作会加锁,加锁的过程要分有索引和无索引两种情况,如:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age=<span class="hljs-number">11</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>
</div></code></pre>
<p>id 是这张表的主键，是有索引的情况，那么 MySQL 直接就在索引数中找到了这行数据，然后干净利落的加上行锁就可以了。
而下面这条语句</p>
<pre class="hljs"><code><div><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> age=<span class="hljs-number">11</span> <span class="hljs-keyword">where</span> age=<span class="hljs-number">10</span>
</div></code></pre>
<p>表中并没有为age字段设置索引，所以MySQL无法直接定位到这行数据。那MySQL会为这张表中所有行加行锁。在加上行锁后，MySQL 会进行一遍过滤，发现不满足的行就释放锁，最终只留下符合条件的行。虽然最终只为符合条件的行加了锁，但是这一锁一释放的过程对性能也是影响极大的。所以如果是大表的话，建议合理设计索引，如果真的出现这种情况，那很难保证并发度。</p>
<h1 id="%E7%B4%A2%E5%BC%95">索引</h1>
<h2 id="%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%AF%B9%E4%BA%8E%E6%99%AE%E9%80%9Ab%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9">聚簇索引相对于普通B+索引的优点?</h2>
<p>叶子结点上保存了数据,可以直接取出来,不需要回表操作;</p>
<h2 id="b%E6%A0%91%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8b%E6%A0%91%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91b%E6%A0%91%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94%E7%BA%A2%E9%BB%91%E6%A0%91%E5%BF%AB-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFb%E8%80%8C%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">B+树索引原理、为什么使用B+树而不使用红黑树，B+树为什么比红黑树快? 为什么是B+而不是平衡二叉树?</h2>
<p>B+树是多叉树，深度更小，B+树可以对叶子节点进行顺序遍历，B+树能够更好地利用磁盘扇区；</p>
<ol>
<li>
<p>对于磁盘的读取应该尽可能的减少IO次数。而红黑树本身是一棵二叉树, 深度相对B树太大, 意味着IO次数会更多;</p>
</li>
<li>
<p>根据局部性原理与磁盘预读特性,当一个数据被用到时，其附近的数据也通常会马上被使用,预读的长度一般为页的整倍数;</p>
</li>
<li>
<p>每次新建结点时，直接申请一个页面的空间，这样可以保证一个结点的大小等于一个页面，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
</li>
</ol>
<h2 id="%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%E5%9C%A8linux%E7%9A%84%E7%A3%81%E7%9B%98%E4%B8%8A%E6%98%AF%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84">索引查找在Linux的磁盘上是怎么操作的?</h2>
<p>例如查找id=100的数据,b+树有三层,所以一共三次io(如果根结点加载到内存了就是两次io):</p>
<ol>
<li>把根结点所在的磁盘块加载到内存,在内存中二分查找到100或者100节点所在区间;</li>
<li>加载对应的第二层节点,继续在第二层结点二分查找,找到100或者100所在的区间;</li>
<li>加载第三层结点,找到100对应的行记录;</li>
</ol>
<h2 id="myisam%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84innodb%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84innodb%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E8%A6%81%E6%9C%89%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95">myisam的索引结构，innodb的索引结构，innodb为什么必须要有主键索引?</h2>
<p>myISAM索引是非聚集索引,B+树实现,在叶子结点保存了行地址;innodb是聚集索引,同样是B+树实现,但是在叶子结点保存了整行数据;</p>
<p>聚集索引的优点:</p>
<ol>
<li>聚集索引主键访问速度更快;</li>
<li>如果能覆盖索引,则可以使用普通索引上主键的值,无需回表;</li>
</ol>
<p>缺点:</p>
<ol>
<li>插入数据的速度严重依赖插入顺序;</li>
<li>更新主键的代价会比较高。和插入数据时的问题一样，可能会出现 “页分裂” 使得性能变差;</li>
<li>通过二级索引查找数据时需要两次IO;</li>
</ol>
<p>主键具有唯一性,而且我们一般规范必须要自增主键,这样设计数据的访问速度会快很多;因为自增唯一的主键,在每次新增记录时直接写在b+树的尾部,只需要对一个页进行操作;(如果是不规则的插入,会导致<em>页的分裂</em>,要操作3个页);innodb所有数据保存根据主键生成的B+树上,所以必须要有主键索引;</p>
<p>如果没设计主键,innodb会找到第一个具有唯一性的索引作为主键,如果没有,则创建一个隐藏的row_id作为主键;</p>
<h2 id="%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%87%8F%E5%B0%91io%E6%93%8D%E4%BD%9C">添加索引，为什么可以减少io操作?</h2>
<p>没有索引的情况下,需要走全表扫描;有索引的情况下,可以快速定位数据;</p>
<h2 id="innodb%E5%90%84%E7%A7%8D%E7%B4%A2%E5%BC%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">innodb各种索引的时间复杂度?</h2>
<p>B+tree: 插入删除都是O(1)的时间;查找是O(logN) (以M阶为底,N代表)</p>
<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%88%97%E9%80%89%E6%8B%A9%E6%80%A7">什么是联合索引与列选择性?</h2>
<ul>
<li>多个字段建立索引,就是联合索引, 联合索引的叶子节点排序是按照索引字段的顺序来的, 先按照A排序、再按照B排序; 所以使用联合索引查询的时候有最左匹配原则;</li>
<li>列选择性是这一列数据的多样性, 如果一列有大量重复数据, 说明这一列的选择性比较低; 通常这种选择性低的列不会建立索引,如果建立索引也不允许查询重复量大的那个数据,因为查询优化器会将其转换为全表扫描;</li>
</ul>
<blockquote>
<p>注意: 1. 最左匹配原则遇到范围查询就停止匹配; 2. where顺序不重要,优化器会自动调顺序到与索引一致;</p>
</blockquote>
<h2 id="%E7%8E%B0%E6%9C%89%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%9C%BA%E6%99%AF-%E8%A6%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3-1-%E5%81%87%E5%A6%82%E8%A6%81%E6%9F%A5-a-in--and-b-in-%E6%80%8E%E4%B9%88%E5%BB%BA%E7%B4%A2%E5%BC%95-2-mysql-%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%A9%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84-3-%E5%81%87%E5%A6%82%E6%9F%A5%E8%AF%A2-a-in--mysql-%E6%98%AF%E9%92%88%E5%AF%B9-n-%E4%B8%AA%E5%80%BC%E5%88%86%E5%88%AB%E6%9F%A5%E4%B8%80%E6%AC%A1%E7%B4%A2%E5%BC%95-%E8%BF%98%E6%98%AF%E6%9C%89%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%93%8D%E4%BD%9C">现有一个新的查询场景, 要怎么解决? 1. 假如要查 A in () AND B in (),怎么建索引? 2. MySQL 是怎么利用索引的? 3. 假如查询 A in (), MySQL 是针对 N 个值分别查一次索引, 还是有更好的操作?</h2>
<ul>
<li>
<ol>
<li>最好是两个字段建联合索引; 否则就尽量给选择性高的那一列建索引;但是如果in的rows过多, 优化器走扫表;
// todo</li>
</ol>
</li>
</ul>
<h2 id="%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E9%97%AE%E9%A2%98abc-%E4%B8%89%E4%B8%AA%E5%AD%97%E6%AE%B5%E5%BB%BA%E7%AB%8B%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%88%97%E5%87%BA%E4%BA%86%E5%87%A0%E7%A7%8D%E6%9F%A5%E8%AF%A2%E7%BB%84%E5%90%88%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%83%BD%E5%91%BD%E4%B8%AD%E7%B4%A2%E5%BC%95">联合索引的问题，A,B,C 三个字段，建立联合索引，列出了几种查询组合判断是否能命中索引</h2>
<blockquote>
<p>ps. 当联合索引只有两个字段时,A AND B与B AND A其实都是可以的; 但是当联合索引字段大于两个时,就需要注意顺序了;</p>
</blockquote>
<ul>
<li>A、AB、ABC三种查询都能命中索引;</li>
</ul>
<h2 id="%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E9%A1%BA%E5%BA%8F%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D">联合索引中的字段顺序会产生什么影响</h2>
<p>最左匹配原则：要想SQL执行的时候能够用到联合索引，那么联合索引中的第一个字段一定要在where语句中，并且不能让该字段参与任何运算;</p>
<h2 id="%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%BB%BA%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%BB%BA">什么情况下需要建索引，什么情况下可以不建</h2>
<ul>
<li>sql查询缓慢,需要扫表;</li>
<li>只用到主键、低选择性，那么就不需要增加索引;</li>
</ul>
<h2 id="select--from-t-where-a-and-b-order-by-c-limit-0100-%E5%A6%82%E4%BD%95%E5%8A%A0%E7%B4%A2%E5%BC%95">select * from t where a=? and b&gt;? order by c limit 0,100 如何加索引</h2>
<p>如果是我建的话 index （ a,b,c ）
根据 ab 查询到的数据，已经把 c 进行了排序了。。。
这个你理解有问题，他是考察你的最左匹配原则 正确答案应该是 acb 或者 cab.
我最近看的时候说加了范围之后后面查询不走索引，自己又试了一下发现也走，不明所以
是这样的 范围会用到一部分 但是接下来绝对会用到了。
首先 explain 的时候要避免 type=all 和 filesort 这两个出现
比如条件是 a&gt;10 b=5 我索引弄成 a,b 也是能用到 a 这个部分的 但是 b 就用不到了
但是如果索引是 b,a 就会完全用到索引。
另外就是 order by 这个
如果你 select c order by c 索引是 c 开头 是可以用的上的
但是 select * order by c 这就不行了
所以这道题是有陷阱的，你要考虑到表中是否是只有 abc 三个字段 那么答案是唯一的 cab
否则就是 ab。也就是说我之前也说的不对。
这道题表面是考最左匹配 其实也包含了聚簇索引相关知识。</p>
<h1 id="%E5%81%8F%E8%BF%90%E7%BB%B4%E5%88%86%E5%B8%83%E5%BC%8F">偏运维/分布式</h1>
<h2 id="mysql%E4%B8%BB%E4%BB%8E%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%9C%89%E4%BB%80%E4%B9%88%E7%BB%86%E8%8A%82%E6%88%96%E8%80%85%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">mysql主从怎么实现?有什么细节或者常见问题?</h2>
<pre><code>// todo
</code></pre>
<h2 id="mysql%E6%80%8E%E4%B9%88%E8%BE%BE%E5%88%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7">mysql怎么达到分布式一致性</h2>
<p>如果是主从一致性,见下面的问题: <code>mysql主从的时候有没有遇到过主从延迟同步的情况？是怎么解决的？</code></p>
<blockquote>
<p>see <a href="https://blog.kido.site/2018/11/24/db-and-cache-preface/">缓存与数据库一致性</a></p>
</blockquote>
<h2 id="mysql%E4%B8%BB%E4%BB%8E%E7%9A%84%E6%97%B6%E5%80%99%E6%9C%89%E6%B2%A1%E6%9C%89%E9%81%87%E5%88%B0%E8%BF%87%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E5%90%8C%E6%AD%A5%E7%9A%84%E6%83%85%E5%86%B5%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84">mysql主从的时候有没有遇到过主从延迟同步的情况？是怎么解决的？</h2>
<blockquote>
<p>高性能mysql 10.7.14 过大的复制延迟
主从同步流程:</p>
</blockquote>
<ol>
<li>
<p>在master机器上的操作:</p>
<p>当master上的数据发生变化时，该事件变化会按照顺序写入bin-log中。当slave链接到master的时候，master机器会为slave开启binlog dump线程。当master的binlog发生变化的时候，bin-log dump线程会通知slave，并将相应的binlog内容发送给slave。</p>
</li>
<li>
<p>在slave机器上操作:</p>
<p>当主从同步开启的时候，slave上会创建两个线程：I\O线程。该线程连接到master机器，master机器上的binlog dump 线程会将binlog的内容发送给该I\O线程。该I/O线程接收到binlog内容后，再将内容写入到本地的relay log；sql线程。该线程读取到I/O线程写入的ralay log。并且根据relay log的内容对slave数据库做相应的操作。</p>
</li>
</ol>
<p>解决方法:</p>
<ul>
<li>架构方面: <strong>最好的办法是在设计程序时能够容忍出现延迟</strong>(例如原神抽卡记录半个小时才更新).读写分离缓解主库压力、读做redis/memecache缓存,缓解读压力;</li>
<li>硬件方面: 升级cpu、升级磁盘阵列、保证主从在同一个交换机下,网速足够快;</li>
<li>主从同步加速: 禁用从库的一些配置(但是如果要将从库提升为主库,这些配置记得修改回来)</li>
<li>具体情况具体分析:
<ol>
<li>不要重复写操作代价高的部分: 例如一个超大表的<code>update group by</code>操作,这个操作在主库以及每个从库都要执行一遍,从而导致延迟.解决办法有:拆分优化这个sql,尽量不使用group by;或者准备一个从库专门运行这个sql,将结果用<code>load data infile</code>快速载入主库中;</li>
<li>同步的瓶颈通常出现在某些表上,如果app是这些表的唯一更新源(该表对其他表没有依赖),可以考虑在复制之外单独处理这些表;</li>
</ol>
</li>
</ul>
<p>靠谱的解决办法: <a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959442&amp;idx=1&amp;sn=feb8ff75385d8031386e120ef3535329&amp;scene=21#wechat_redirect">DB主从一致性架构优化4种方法</a></p>
<ol>
<li>半同步复制, 直接改数据库配置就行了; 利用数据库原生功能，比较简单;缺点是主库的写请求时延会增长，吞吐量会降低;</li>
<li>读写不分离; 从库只拿来容灾;读的压力分摊到缓存;</li>
<li>数据库中间件: 记录所有路由到写库的key，在经验主从同步时间窗口内（假设是500ms)key存在就走主库读,否则走从库读; 缺点是需要造轮子;</li>
<li>方法3的简化版: 到写库的key记缓存,同时设置超时时间(假设是500ms);缓存命中走主库,缓存未命中走读库; 缺点是引入了缓存,读写都多一步cache操作;</li>
</ol>
<h2 id="%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5">缓存更新策略</h2>
<ol>
<li>读: 命中缓存,未命中则读数据库,再写入缓存;同时缓存记失效时间,防止没有更新操作时导致一直读到脏数据;</li>
<li>写: 写数据库,再删缓存;</li>
<li>第二步的问题: 如果缓存刚好失效,A读库拿到旧值, B更新同时删除缓存,A再写入缓存,这样就一直是脏数据库了; 但是这个问题出现概率很小,因为读库写缓存速度很快,不可能写做完了读还没做完;而且缓存设置了失效时间,过几分钟又回拉新的数据出来;</li>
</ol>
<h2 id="%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E9%A1%B9%E7%9B%AE%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8">说一说你项目里为什么要分库分表？在什么情况下会使用分库分表。</h2>
<p>一句话概括就是为了提高数据库的读写的效率，更重要的是提高读效率，提高查询的性能，解决数据量过大从而导致的数据库性能下降的问题，如果业务数据日增量比较大，那么就要提前预估，现有单库单表的数据量读写速度能支撑多久，提前规划时间改造。</p>
<p>举个例子说明，比如用户信息表中现在有3000w条用户数据，此时我们需要在这个表中 insert 一条新的数据，insert 完毕后，数据库会针对用户表重新建立索引，3000w 行数据建立索引的系统开销还是不容忽视的。</p>
<p>假如我们将这个大表分成3个分表，从user_0，user_1，user_2，3000w行数据平均分3张表，每个子表里有1000w行数据，对1000w行的表中insert数据，建立索引的时间就会下降，从而提高了DB的运行时效率，进而提高并发量。</p>
<p>当然分表的好处还不止这些，还有诸如减少写操作时锁范围等，都会带来很多明显的优点。</p>
<p>分库： 提高架构可用性，减少单点故障，有效分担一个库的压力，只分库不分表，常用于读写分离场景，一主多从，主库负责写，从库用于读，从库从主库同步更新数据，保持数据一致，适用于写入少读取多的场景。
分表： 把数据分片拆分，多个表数据减少，insert 插入速度提高，读取速度也得以提高。</p>
<h2 id="%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84">怎么做分库分表的？</h2>
<p>还拿用户信息表举例：</p>
<ul>
<li>不分库只分表： 将db库中的user表拆分为3个分表，user_0，user_1，user_2，每个子表里有1000w行数据，这3个表还位于同一个库中，属于水平切分。</li>
<li>只分库不分表： 将db库拆分为db_0，db_1，db_2 三个库，同时在db_0，db_1，db_2 库中各自新建一个user表，db_0.user，db_1.user，db_2.user 表中各自只存原来的db.user表中的部分数据，每个子里有1000w行数据。</li>
<li>既分库又分表： 将db库拆分为db_0，db_1，db_2 三个库，db_0中包含user_0、user_1两个分表，db_1中包含user_2、user_3两个分表，db_2里有user_4，user_5。这样每张表里有500w行数据。</li>
</ul>
<h2 id="%E4%BD%A0%E6%98%AF%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E7%AD%96%E7%95%A5%E5%81%9A%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%88%96%E8%80%85%E8%AF%B4%E6%A0%B9%E6%8D%AE%E4%BB%80%E4%B9%88%E7%AE%97%E6%B3%95%E6%8B%86%E5%88%86%E6%95%B0%E6%8D%AE">你是使用什么策略做的分库分表？或者说，根据什么算法拆分数据。</h2>
<ul>
<li>
<p>对key取模法： 项目中我主要是用的这个方法给user表做的分表。</p>
<p>如采用第三种即分库又分表方法为例，根据userId把3000w最终分6张表，n = 6，userId = 10001 取模（10001% 6 = 5）这条数据落在db_2 第user_4分片上，10002 % 6 = 0，落在db_0 第user_0个分片上，以此类推，（注意：分片数从0计数），可以哈希后再取模，Hash（userId）% n ，此种方法数据分布较均匀。</p>
</li>
<li>
<p>RANGE分区：</p>
<p>这个是我额外了解的方法，userId 从0 - 500w一张表，5000001 - 1000w一张表，依此类推。目前没有在项目中使用过此方法，我觉得这个方法在增量表场景中会造成数据分布不均匀，没道理是用此方法。</p>
</li>
<li>
<p>时间分区：</p>
<p>这个方法很实用，适用于订单数据拆分，如按天分表，按月分表，按年分表，时间越久的数据被查询的概率就会越低，类似冷热数据分离，比如我用ES给订单数据做归档，就是使用的按月索引。</p>
</li>
</ul>
<h2 id="%E6%8B%86%E5%88%86%E6%95%B0%E6%8D%AE%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E5%AF%B9key%E5%8F%96%E6%A8%A1%E6%B3%95%E5%A6%82%E6%9E%9C%E4%B8%9A%E5%8A%A1%E7%AA%81%E9%A3%9E%E7%8C%9B%E8%BF%9B%E5%88%B02020%E5%B9%B4%E5%B0%B1%E5%8F%98%E4%B8%A4%E4%BA%BF%E7%94%A8%E6%88%B7%E4%BA%86-%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E5%AF%B9key%E5%8F%96%E6%A8%A1%E6%B3%95%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%90%97">拆分数据使用的是对key取模法，如果业务突飞猛进，到2020年就变两亿用户了, 这个时候对key取模法会有什么问题吗？</h2>
<p>对key取模法有一个缺点：如果n变大，比如现在要把分片数调整为 n=12，那么之前已经计算好的取模值会变，那已经存在的3000w数据是不是要重新分片了？答案是会的，你将要面临大量额外的数据迁移工作，如果这个n变动频繁，是不是考虑还有更好的解决办法，答案就是一致性hash算法，这个算法触及了我的知识盲区，这个算法复杂，可以参考一致性Hash算法及使用场景进一步了解。</p>
<h2 id="%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%88%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%BA%93%E6%AF%94%E8%BE%83%E5%90%88%E9%80%82%E5%88%86%E5%A4%9A%E5%B0%91%E4%B8%AA%E8%A1%A8%E5%90%88%E9%80%82%E6%9C%89%E7%BB%8F%E9%AA%8C%E5%8F%AF%E5%BE%AA%E5%90%97">分库分表，分多少个库比较合适，分多少个表合适，有经验可循吗？</h2>
<ul>
<li>
<p>表数目决策：</p>
<p>一般情况下，建议单个物理分表的容量不超过1000万行数据。通常可以预估2到5年的数据增长量，用估算出的总数据量除以总的物理分库数，再除以建议的最大数据量1000万，即可得出每个物理分库上需要创建的物理分表数。</p>
</li>
<li>
<p>库数目决策</p>
<p>计算公式：按照存储容量来计算 = （3到5年内的存储容量）/ 单个库建议存储容量 （单个库建议存储容量 &lt;300G以内）
DBA的操作，一般情况下，会把若干个分库放到一台实例上去。未来一旦容量不够，要发生迁移，通常是对数据库进行迁移。所以库的数目才是最终决定容量大小。
最差情况，所有的分库都共享数据库机器。最优情况，每个分库都独占一台数据库机器。一般建议一个数据库机器上存放8个数据库分库。</p>
</li>
</ul>
<h2 id="%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E6%8C%91%E6%88%98">分库分表会带来哪些挑战</h2>
<ul>
<li>
<p>分布式ID问题：</p>
<p>在分库分表后，我们不能再使用MySQL的自增主键。因为在插入记录的时候，不同的库生成的记录的自增ID会出现冲突。因此需要有一个全局的ID生成器。系统需要额外的可靠分布式ID生成器服务。</p>
</li>
<li>
<p>分布式事务问题：</p>
<p>分布式事务是分库分表绕不过去的一个坎，因为涉及到了同时更新多个数据库，如何保证要么同时成功，要么同时失败。关于分布式事务，MySQL支持XA事务，但是效率较低。柔性事务是目前比较主流的方案，柔性事务包括：最大努力通知型、可靠消息最终一致性方案以及TCC两阶段提交。但是无论XA事务还是柔性事务，实现起来都是非常复杂的。</p>
</li>
<li>
<p>最低代价动态扩容问题：</p>
<p>记得一次面试中，上家单位是我第一次使用分库分表，也是用户表，我采用的是取模法将1亿用户分8个表，面试官问我，如果你的用户变成2亿3亿甚至更多，8张表远不够，要分成16张表，这是时候你要重新将几亿数据重新刷盘，你觉得这样合理吗？还有没有什么更好的办法？(一致性hash)</p>
</li>
<li>
<p>分库分表后的Join操作：</p>
<p>一般情况下，分库分表后，就不能再和单库单表一样进行Join操作，应尽量避免这样的查询，可以采用字段冗余，这样有些字段就不用join去查询了。</p>
</li>
</ul>
<h2 id="%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%B8%B8%E7%94%A8%E4%B8%AD%E9%97%B4%E4%BB%B6">分库分表常用中间件</h2>
<ul>
<li>MyCAT，阿里cobar基础上进行二次开发，解决了cobar当时存在的一些问题，并且加入了许多新的功能在其中。目前MyCAT社区活跃度很高，广受好评的数据库中间件，已经在很多产品上进行使用了。</li>
<li>TDDL，TDDL是Tabao根据自己的业务特点开发了，主要解决了分库分表对应用的透明化以及异构数据库之间的数据复制。</li>
<li>Sharding系列，包括ShardingJDBC，Sharding-Proxy，Sharding-Sidecar，Sharding-JDBC是ShardingSphere的第一个产品，也是ShardingSphere的前身。 它定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。Sharding-JDBC的优势在于对Java应用的友好度。</li>
</ul>

</body>
</html>
