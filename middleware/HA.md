# 高可用
## 问题
### 在面对未知的流量暴增，可以预先怎么处理?
### 设计一个抢红包的系统架构、如何保证每个人抢到、如何抗住流量?
### 设计秒杀系统要考虑哪些点? 从性能角度上如何保证秒杀系统稳定? 
这是一个读多写多的大并发场景，解决思路是：读缓存，写异步；整个服务只走内存与分布式锁，其他操作全走MQ让消费者后台慢慢拉；
- 数据预热：提前将库存等数据加载到内存；
- CDN缓存、页面静态化，防止用户长时间见到白页面；
- 超卖问题：单节点情况加锁检查库存扣库存；分布式情况加分布式锁再检查库存扣库存；
- 流量削峰；

### 分布式锁是排他的,如何提升存储效率?​ 
类似于channel的实现思路，锁会大幅影响效率，那尽量减小锁粒度，并做CAS操作；

### 如何理解幂等?幂等性有什么实现方式?设计幂等方案防止重复提交?
幂等: 对一个系统,使用同样的条件,一个请求和多次请求对系统资源的影响是一致的.幂等通常通过业务与逻辑两个方面来解决：

常见设计方案: 
- 客户端按钮提交限制，每次提交一个请求时，按钮置为不可用;
- 乐观锁: 加一个版本号,相同版本只操作一次;
- 使用去重索引: 加一个不能重复的字段,加唯一索引,避免数据被重复消费;
- 后台系统逻辑层处理，生成保存唯一ID（流水号），每次请求先校验流水号是否已经存在，存在则表示重复操作，直接返回上一次操作结果。
- 使用token机制: 携带token请求过一次之后使token失效;
- 分布式锁，如引入Redis分布式锁，防止其他请求重复操作。
- 请求队列，引入MQ排队的方式让请求有序处理;

### 如何生成分布式唯一id?
需求: 
- 可以当作数据库的唯一主键, 但是需要支持分布式高并发;
- 有分页/排序的业务需求
- 可能趋于时间递增,在排序业务里可以代替create time进行主键排序

因此提供 ID-gen-service 全局id生成服务; 
> 方案来源沈剑的[分布式ID生成方法](https://mp.weixin.qq.com/s/0H-GEXlFnM1z-THI8ZGV2Q) 评论里还补充了zk监听锁生成全局唯一id需要13ms的时间, 性能不够行;

#### 方案一 单点批量ID生成服务
- 数据库id从1开始;
- id-gen将数据库的id一次+200(相当于提前申请200个id), 然后再发放这200个id; 

优点: 
- 通过这种方法可以让数据库压力降到主键自增的1/6;
- 能保证id的绝对有序;
- 可以通过`vip+keepalived`自动切换影子服务来达成高可用;

缺点:
- 服务仍然是单点;
- 服务挂了会出现id空洞; 因为服务挂了的话中间会有部分id没发完,启动时先读数据库的max id;

#### 方案二 类雪花算法
> 雪花算法: 一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID. (机器编号是固定值, 序列号是从0开始递增的值,12bit可以保存2^12=4096, 也就是每毫秒生成4096个序号)

基于雪花算法可以设计自己的id生成算法: 
- 对于mysql, 存在int =int32, 最多支持32bit; 建议使用bigint类型,也就是int64, 有64bit的空间;
- 按照`毫秒数|固定数据|序列号`的形式分配`63bit`;
- 比如预留10年的数据: 10年*365天*24小时*3600秒*1000毫秒=320*10^9, 豪秒数至少留`2^39=39bit`;
- 再根据QPS定义, 比如单机QPS为10w, 毫秒请求最高为100, 则序列号大小为`2^7=128`即7bit就够用了;
- 因此该算法最大并发量为: `1000*(2^7)` = 12w;

缺点:
- 并不是绝对递增的, 不同机器毫秒数可能有差异;而且必须严格保证不更改机器的时间,不然会造成冲突;
- 分表时, 如果对id取模进行分表; 在低并发量时, 序列号部分往往取的都是0, 容易造成分表不均匀;解决办法是序列号最后一位不严格从0开始,而是随机取0-7(2^3)

#### 百度和美团的轮子: 
- [美团Leaf](https://tech.meituan.com/2017/04/21/mt-leaf.html) https://tech.meituan.com/2019/03/07/open-source-project-leaf.html
- [uid-generator](https://github.com/baidu/uid-generator)

## 服务治理/链路追踪
### 服务调度中心的感知与动态上下线如何实现?
zk是通过临时节点来实现的；consul通过心跳与健康检查函数来实现;

### 服务启动的时候服务基本信息被注册到注册中心，如果服务提供者挂了，注册中心如何知道服务不可用了呢？
服务掉线分为*主动下线*和*心跳检测*，
- 重启之前主动通知注册中心; 或者是在管理后台手动直接摘掉机器，这个是主动下线;
- 心跳检测是处理服务非正常下线（如断电断网）的情况，这个时候如果注册中心不知道该服务已经掉线，一旦被其调用就会带来问题。为了避免出现这样的情况，注册中心增加一个心跳检测功能，它会对服务提供者（Provider）进行心跳检测，比如每隔 30s 发送一个心跳，如果三次心跳结果都没有返回值，就认为该服务已下线，赶紧更新 Consumer 的服务列表，告诉 Consumer 调用别的机器。

### 如果注册中心挂了，比如你用的是 Zookeeper，如果Zookeeper挂了，那服务之间还能相互调用吗
- 注册中心通常是集群配置，会重选leader
- 网关（与api服务都）做了缓存设计，本地缓存了服务列表;

### 配置中心, 实时配置推送怎么做?
### 为什么选择所有的组件依赖放在配置中心中控制?
### etcd 怎么保持一致性的? 脑裂怎么解决的？
### 线上熔断降级怎么做的?
### 配置中心的核心数据表是怎么设计的?
### 长调用链如何定位问题？
链路追踪（Trace）,收集各服务的日志，上报日志，分析日志，保存展示。其关键核心在于调用链，为每个请求生成全局唯一的ID（Traceld），通过Traceld 将不同系统的“孤立地”调用信息关联在一起，还原出更多有价值的数据。

通过一个Trace查询某一次请求，这个Trace是全剧唯一，通过这个链路追踪系统，你可以清楚的知道服务调用深度，涉及服务个数，每个服务调用的时间及状态，到底是哪个服务出现异常，具体到方法名，查找耗时长的链路时，

### 服务调用出现闭环，如何快速的搜索出来?
### 讲解jaeger全链路原理、 traceid 的生成规则

## 维稳三板斧: 限流、熔断、降级
### 讲一下你对限流、熔断、降级的理解?
- 限流：限流包括单机限流和集群限流.系统某一环节加一个开关，好比地铁进站口，人多要排队，保证流量持续进入，而不是撑破服务器大家都无法使用;比如将系统QPS控制在最高2000，后面的用户告诉他“系统繁忙，请稍后再试”，这样一来无非就是多点几下或者等几分钟，不至于挂掉服务。
- 降级备案：比如商品列表查询，默认查询的是 Redis 集群，各种故障赶在一起，Redis 所有集群都挂了不能用了，这个时候怎么办，设计一个备胎Elasticsearch，查询速度可能没 Redis 快，但好歹备胎还能用。
- 熔断：这个可以理解成家庭电路中的保险丝，电流有异常后自动开启熔断保护，系统流量也同样原理。

举例： 我对公司内部订单查询系统做的优化，订单查询是运营人员每天都要使用的功能，一定要保证服务可用，还要迅速响应，为了解决这个问题，我使用了ES作为查询主库，如ES故障，系统会自动降级到MySQL查询，完美解决了性能和可用性的问题。

- 常用限流降级组件: Hystrix、Sentinel、Resilience4j、ratelimit

> 推荐 《亿级流量网站架构核心技术》

### 能简单介绍下Hystrix有哪些功能吗？
系统在 Hystrix 的保护下，可以长期处于高可用的状态，常用的功能有以下几点：
- fail-fast（快速失败）: 对无法及时处理的请求快速失败，降低系统负载，而不是排队;
- Fallback优雅降级机制: 
- 线程/信号量隔离机制: 
    - 线程隔离：请求会根据自己的key获取对应线程池中的线程执行，动态设置线程池参数，这样自然地将不同的请求隔离开来，支持异步来提高接口性能。不同请求直接不影响，例如service1请求缓慢，但是service2和service3还是可以正常工作，缺点就是线程切换影响性能。
    - 信号量隔离：一个请求中访问了service1、service2、service3，其中service1请求超时，将导致整个信号量一直不释放，其他请求一直无法接受。
    - 对于延迟小的请求（例如访问缓存或者本地访问数据库）来说，线程池带来的开销是非常高的，你可以考虑采用其他方法，例如非阻塞信号量（不支持超时）来实现依赖服务的隔离。但绝大多数情况下，Netflix 更偏向于使用线程池来隔离依赖服务，因为其带来的额外开销可以接受，并且能支持包括超时在内的所有功能。

Hystrix的主要功能特性：
- 熔断器机制：熔断器可以理解成保险丝，项目里使用Hystrix Command，当 Hystrix Command请求后，如果服务失败数量超过一定比例(比如默认50%)，断路器自动熔断，该服务将进入熔断状态，后续请求都会进入fallback。
- 降级机制：通过fallbackMethod注解，当请求后端服务出现异常的时候, 为了避免影响到其他业务逻辑，可以使用fallback方法指定的方法快速返回，或启用“备胎方案”。
- 环境隔离：包括线程隔离和信号量隔离。
- cache：Hystrix支持将一个请求结果缓存起来，下一个具有相同key的请求将直接从缓存中取出结果，减少请求开销。

### 说到线程隔离，那实际使用中是否打开超时线程中断开关？
一般情况下我们会打开超时中断开关，目的是及时释放线程资源。通过hystrix.command.default.execution.isolation.thread.interruptOnTimeout = true 设置。但是如果是写数据库命令，或者记录关键日志命令的情况下，需要命令执行完毕情况，可关闭超时中断。

### 如何估计线程池大小的？
要正确设置线程池的大小，需要分析所部署系统的CPU个数、内存大小、任务类型（计算密集、IO密集等），对于计算密集型任务，线程池大小和CPU个数相近通常能实现最优利用率，对于IO密集型任务，线程池的最优大小的计算公式：线程池大小=CPU个数* (1 + 任务等待时间/ 任务处理时间)。

### 哪些场景系统使用了限流？为什么要使用限流？如何限流，限流算法，对于ddos攻击怎么处理?
所有访问频繁的服务都可以做限流; 秒杀活动，或者容易被爬虫爬的信息类页面，以及系统核心服务，这些都需要做限流，比如大众点评首页，因为推荐了一些高质量店铺信息，经常被同行或者门户类公司的爬虫爬取信息，这个时候我们就要对首页做限流操作。秒杀活动，系统核心高 QPS 服务，都需要考虑限流。

限流算法:
- 计数器方法: 固定时间窗口，比如 1min/1h，设置一个计数器统计单位时间内一个请求的访问量，超过计数器最大值，可以让请求放入等待队列 or 直接拒接访问，这种方法简单粗暴，但是易造成突刺现象。
- 漏斗算法: 可以理解成一个固定容量的漏桶，不管流量多还是少，我都按照常量固定速率流出水滴，如果流入水滴超出了桶的容量，就让水溢出。这种算法优点是稳定速率，缺点是无法面对突发流量。
- 令牌桶算法: 让每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择等待可用的令牌，或者直接拒绝。优点是系统发放令牌的速率是可变的，能够面对突发流量，缺点是有点复杂。

对于核心服务限流的值可以通过以下方法来设置合理的值:
- 观察评估法：看看QPS、流量环比最大值，最小值，平均值；
- 压力测试法：找 QA，半夜业务低峰期，看看系统能承受的最大 QPS。

### 我现在要做一个限流功能, 怎么做?
1. 令牌桶这个限流要做成分布式的, 怎么做?
    令牌桶维护到 Redis 里，每个实例起一个线程抢锁，抢到锁的负责定时放令牌

2. 怎么抢锁?
    Redis setnx, 锁怎么释放?抢到锁后设置过期时间，线程本身退出时主动释放锁，假如线程卡住了，锁过期那么其它线程可以继续抢占,加了超时之后有没有可能在没有释放的情况下, 被人抢走锁,有可能，单次处理时间过长，锁泄露,怎么解决?

3. 换zk，用心跳解决,不用zk的心跳, 可以怎么解决这个问题呢?
    每次更新过期时间时，Redis 用 MULTI 做 check-and-set 检查更新时间是否被其他线程修改了，假如被修改了，说明锁已经被抢走，放弃这把锁

4. 假如这个限流希望做成可配置的, 需要有一个后台管理系统随意对某个 api 配置全局流量, 怎么做？
    在Redis里存储每个API的令牌桶key，假如存在这个key，则需要按上述逻辑进行限流

## 警报/监控/日志采集
### 警报怎么做的? 统一接入监控项怎么做的?
### Prometheus 单实例数据量级 hold 不住了，有什么解决方案？

### 有写项目里有使用了ES，哪些场景用到了ES？
凡事大数据量且需要检索的都可以想到ES，传统关系型数据库查询速度变慢，数据库分表联合查询速度慢。

- 大数据量聚合检索和排序，如计算用户订单总金额，订单数据等。
- 自动补全，如搜索框通过关键字自动补全。
- 高亮查询。
- 关键字检索，模糊检索，拼音查询。
- 记录系统后台日志，日志检索。
- 分布式的实时文件存储，每个字段都被索引并可被搜索

### 关于ES的一些概念名字你了解多少？如索引，文档，倒排索引这些东西你是怎么理解的？
- 索引（Index）：索引的概念相当于MySQL里数据库的概念，用ES创建一个索引就是创建一个库，比如电商系统里给订单创建一个订单的索引，那客服系统就可以通过订单索引快速查询订单所有信息快速处理客诉。

- 文档（Document）：ES属于文档型数据库，文档的概念就相当于MySQL里一条数据的概念，很多个文档（很多条数据）构成了一个索引。

- 类型（Type）上面说文档的概念就相当于MySQL里一条数据的概念，MySQL里一条数据有很多个字段，比如订单号，用户手机号，订单金额等，Type 的概念相当于根据每个字段聚合所一张表，如根据订单号分组，按照手机号分组，这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤文档，无论根据哪个字段搜索都有对应的Type（表）

|	|ElasticSearch|	关系型数据库：MySQL|
|---|---|---|
|对应关系：|	索引	    |库|
|对应关系：|	类型type	|数据表|
|对应关系：|	文档	    |行|
|对应关系：|	字段Field	|列|

倒排索引, 也叫反向索引（Inverted Index）记录每个单词所在行所在位置;
