# 追加
### APM系统
- APM用于监控和管理应用软件性能和可用性, 三大模块分别是集中式日志系统，集中式度量系统和分布式全链接追踪系统；
- 日志系统使用elk；
- 度量系统使用promethus;
- 追踪系统使用jaeger;

### 一致性hash的实现流程
- 设计struct：1. map，key是hash值、value是节点值；2. 哈希环，直接用切片来表示；3. 虚拟节点的倍数；4. hash函数；
- 写流程：添加kv时，根据虚拟节点的倍数，在k前面追加编号，例如倍数是3，那就生成`1key`、`2key`、`3key`这样的key；
- 把生成的key与value添加到map里面；对应的hash添加到切片里面；最后对切片进行排序；
- 读流程：对str（可能是ip地址之类的唯一标示）进行hash，获得的数据在切片（hash环）内做search,找到第一个大于等于hash的值，拿到他的index;
- 如果没找到大于hash的值，默认返回的idx=切片的len，说明整个hash环跑了一圈了，直接取第一个；（在代码里面是以取余的方式来实现）

### 链路追踪原理
- spanid：每次调用做个标识，然后将服务按标识大小排列；
- traceid：每个完整请求的唯一标识；
- parentid：记录是谁调用的；
- 时间戳：调用时间，返回时间；

举例： 
- 客户端发起请求，traceid=1
- 接口请求服务A，traceid=1, spanid=1,parentid=0；
- 服务A请求服务B，traceid=1，spanid=2，parentid=1；
- 服务B请求服务C，traceid=1,spanid=3,parentid=2;

### 数据模型过于耦合怎么办？微服务的连表查询
下下策：
- 拆分服务不拆分db，或者单服务只拿对应的读库，写库都还是一个。优点是服务改造速度快，缺点是逻辑关系混乱，容易挖坑；
- 再加一个聚合服务，对应一个专门的db，通过某种同步机制。把需要的表同步到这个库，然后这个微服务就专门提供这类联表查询，适合实时性要求不高的分析场合；(运营后台查询)

需要区分需求，对于这种查询问题，必须先切分前后台，根据不同的特性做对应的开发：
- 前台通常是：OLTP，业务处理类查询，特点是小查询，吞吐量大，要求速度快，用户对一致性要求高（如订单同步速度）；
- 后台通常是：OLAP，数据分析类查询，特点大数据量查询、分页查询，访问量比较低，单次查询sql时间比较长；可用性/一致性要求不高；

对于后台：
- 聚合服务
- 甚至可以直接去掉service，直接web访问dao层；
- 接入大数据架构；

对于前台：
- 如果是单个用户的查询，数据量明显不大，则join拆分成两个查询，一个服务提供类似于`batchGet`的方法；
    - 这种跨服务查询参数最好还是走全索引；
    - 无法满足跨表的排序需求、筛选需求：
    - 这种处理相当于拆分出来的服务又耦合到一起了，大量数据请求+id的大范围查询容易导致服务雪崩；
    - 请求格式不能是服务A请求服务B，应该是业务层请求服务A，获得ids之后再去请求服务B的`batchGet`，并且要有降级逻辑；例如订单-商品连表，如果商品服务挂了，不影响接口输出，在商品字段处做好处理，比如商品图片用一张通用图片代替；

- （实现较为复杂，这里先占坑）引入数据中间件，不把数据表作为数据源，而是将数据流作为数据源，通过message的方式获取数据并记录.好处是业务彻底解耦，缺点是每个服务都维护一套自己的数据，有大量数据冗余。

- （不知道怎么搞，占坑）仍然是数据中间件，改成用es，将数据集成到es查？

- 比上面稍简单一点的(但还是有很多很多的问题) - 数据冗余、反范式化设计：
    - 冗余字段：订单-商品连表，可以把部分商品字段冗余到订单里面，做一个快照；
    - 整体数据冗余：同步双写/异步双写/线下通过binlog+canel双写；问题是毕竟是两个服务，无法保证实时一致性；

    - 补充一点-基因法分库：使用雪花算法生成全局唯一id时，id最后几位单独拉出来做uid的取模存储（分库基因），使单独一个uid的所有数据落在同一个库里面；缺点仍然是取模的值在扩展之后的问题；
    
    - 数据冗余需要保证最终一致性：
        保证冗余数据最终一致的常见方案有三种：
        - 冗余数据全量定时扫描；
        - 冗余数据增量日志扫描；
        - 冗余数据线上消息实时检测；

### 分布式事务如何实现？

### 鉴权总结
1. session: 不适合分布式，数据保存在服务器上；
2. appkey+secret: 在请求时带上appkey， appkey+secret+参数做一个签名；
3. token服务，通过appkey和secret申请token，token在一定时间内有效，请求申请token必须设置ip白名单；使用token去进行其他api请求；
4. JWT：先做鉴权请求获取token，每次请求带上token；缺点是jwt失效只能通过过期；多设备问题；优点是网上轮子多，实现快速，适合api请求这种无状态的服务；


## 缓冲雪崩、击穿、穿透的解决办法
### 雪崩
雪崩是在某一时间缓存的大量热点key过期，导致大量请求走到DB；

解决办法是缓存的ttl增加随机数；

### 击穿
击穿指某个热点key过期，然后收到大量请求走到DB；

解决办法： 1. 未命中缓存，先加分布式锁，再读DB设置缓存，再释放锁；2. 本文实现的缓冲器singleFlight

### 穿透
穿透指大量查询不存在的数据，不会命中缓存，大量查询查到DB

解决办法是1. 缓存这个key，值设置为nil; 2. 分布式布隆过滤器;