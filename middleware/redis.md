# redis QA
## 数据结构与对象
### Redis的整体存储结构
- redis有五个对象: string、list、hash、set与sort set;
- string有三种底层实现: long int、raw、embstr;
- list有两种实现方式: 压缩列表ziplist、双端链表linkedlist;
- hash有两种底层实现: 压缩列表ziplist、hashtable;
- set有两种底层实现: 整数集合intset、hashtable;
- sort set有两种底层实现: 压缩列表ziplist、跳跃表skiplist;

### redis hash的实现; rehash过程讲一下
- hash有两种底层实现,一个是压缩列表ziplist、一个是hashtable;
- ziplist在hash里面是一个key一个value按照添加顺序排列的;获取len是ziplist的结点数量除以2;
- 当ziplist存在某个key或者value超过64字节,或者k-v数超过512个,ziplist就会转换成hashtable;
- hashtable实现是一个指针数组,数组里单个node保存了k-v值;通过key计算对应的hash值再加上ht的masksize计算出索引值,可以得到这个key在数组里的位置;
- redis的ht是通过拉链法来解决hash冲突的,如果计算出key在数组里的位置已经有数据了,会在这个node里面找到一个next指针,往后遍历直到找到next指针为null的节点,将新数据加到next节点后,组成一个类似链表的结构;
- rehash:当ht保存的kv数量太多或者太少时,需要进行扩容/缩容的操作; 在hashtable里面会的数组是一个二维数组,数组0的位置保存了hash表的数据,1的位置会根据当前数据大小建立一个新的hash表; 然后在每次进行kv操作时会将新数据与更新的数据写到`array[1]`位置的hash表里面;`array[0]`所有数据都转到`array[1]`里面,再将`array[1]`替换掉`array[0]`;


### Redis有哪些结构时间复杂度较高
- 链表,查找更新删除都是O(N), 但是链表一般都是使用pop与push操作,都是对头尾结点进行操作,复杂度O(1);

- 压缩表: 查找更新删除都是平均O(N),更新删除可能是`O(N^2)`(触发连锁更新);压缩表主要用于list、hash与sort set三个类型小数据量时, 使用这个结构的目的是节约空间,因为数据量小,所以O(N)与O(1)或者O(logN)的结构并没有太大量级上的差距;


### redis的zset的使用场景、实现方式;ziplist的限制;跳表数据结构、跳表的时间复杂度
- zset通常用于排序,例如排行榜;另外业务里面经常将score设置为时间戳;
- zset的实现方式是ziplist和skiplist;
- ziplist的限制是,因为是连续一段内存保存数据,查找的复杂度是O(N),如果更新与删除触发了连锁更新,需要进行N次重新分配操作,每次分配复杂度都在O(N),所以复杂度是`O(N^2)`;
- skiplist是对linkedlist的一种优化方式, 将前进指针改成跳跃指针数组, 通过投硬币的方式来决定数组的长度(配置文件限制了最长值,32层或者64层); 指针数组指向下一个有相同高度结点; 因为skiplist是根据score顺序排列的, 这样通过类似`抄近路`的方式减少了索引的复杂度, 理论上时间复杂度近似于二分查找树`O(logN)`;


### 跳跃表，为什么使用跳跃表而不使用红黑树
- 跳表对比红黑树, 优点在于维护平衡的代价很小: 红黑树需要通过左旋右旋和变色来维护二叉树的平衡, 而跳表只需要对前后结点的指针进行操作,然后维护一下索引数组就行了;
- 跳表的范围查询速度极快,只需要找到最小值,对第一层链表进行遍历就行了;而红黑树需要在最小值结点处开始中序遍历查找不超过最大值的节点; 
- 跳跃表对比红黑树的缺点在于索引数组需要额外的内存空间;


## 实现
### redis的内存分配方式、哪个分配器? 内存碎片是怎样发生的，怎样解决。
- redis内存分配器默认是jemalloc: 一共有small、large、huge三种类型的内存块, 每种内存快内部又划分了若干小内存单元;
- 例如一个对象为5kb,分配器有4kb块和8kb块,那么分配器会给他分8kb的块,多余的3kb就变成了内存碎片;在进行频繁更新删除操作时会导致碎片率上升;
- 4.0之前通过重启来解决,4.0之后通过`memory purge`来整理内存碎片;

### Redis连接时的connect与pconnect的区别
pconnect是php里面实现的一个redis连接池, php-fpm会保存这次redis连接直到下次使用或者超时;防止频繁建立redis连接;


### redis的删除策略。定时 定期 惰性 lru
- 定期+惰性; 
- 定期取出随机key抽查过期时间;
- 惰性: 当key读取到时会检查过期时间;
- LRU: `redisObject.lru`字段记录了最后操作时间, 当redis超过设置的内存时会优先释放lru最早的那些对象;


### redis为什么是单线程? 讲epoll底层和两种模式; 
- 因为是纯内存操作,速度足够快;
- 单线程不需要进行上下文切换,减少开销;不需要多进程切换导致消耗cpu,不用考虑锁的问题;
- 使用epoll+简单的事件框架, 将读、写、关闭、连接都转换成了event,然后利用epoll多路复用的特性,不在io上浪费事件;


### 怎么解决redis在并发下商品超卖的问题？
- 通过setnx实现的分布式锁进行库存判断与预扣库存; 
- 下单等操作投递到MQ,后面起几个消费者去拉MQ(注意是拉,如果结构是MQ主动推给消费者,可能会瞬时大流量推挂)


### 为什么在业务里用 Redis, redis有什么优点?
- 短平快: 单线程-并发安全；异步io、纯内存性能高；
- 用的比较多,有各种成熟的高可用/集群方案,踩坑成本低;


### redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？
- redis通过RDB+AOF进行持久化;
- RDB: redis开启子进程, 将数据直接备份成rdb二进制文件,备份周期比较长;
- AOF: 将执行命令写入aof缓冲区,再从缓冲区刷到aof文件里面;
- redis主要是拿来做缓存,应付读多写少的环境,数据保存在内存里,随时可能被LRU, 因此不能做持久化存储; 

RDB优点:
- 适合大规模的数据恢复，如果业务对数据完整性和一致性要求不高，RDB 的启动速度更快，是很好的选择。
- RDB 文件简洁，它保存了某个时间点的 Redis 数据集，适合用于做备份。你可以设定一个时间点对 RDB 文件进行归档，如果 1s 间隔保存一次快照，这样就能在需要的时候很轻易地把数据恢复到不同的版本。
- 考虑到磁盘硬件故障问题，RDB 文件很适合用于灾备，因为单文件可以很方便地传输到另外的数据中心。
- RDB 的性能很好，需要进行持久化时，主进程会 fork 一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的 I/O 操作。

缺点:
- 数据的完整性和一致性不高，因为 SAVE 命令执行是有时间间隔的，比如 5min 备份一次，RDB 可能在最后一次备份时宕机，这 5min 的时间窗数据可能丢失。
- 备份时占用内存，因为 Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍），最后再将临时文件替换之前的备份文件。所以 Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。

AOF:
- 优点: AOF策略最大限度地保证数据不丢失，数据的完整性和一致性更高。
- 缺点: AOF 备份产生的 appendonly.aof 文件较大，数据恢复的时候，也会比较慢，Redis 针对 AOF 文件大的问题，提供重写的瘦身机制。(命令合并)



## 运维/分布式
### redis怎么达到分布式一致性
- 遵循gossip协议发送meet、ping、pong、fail等消息,同步各个结点的信息;
- 哨兵模式使用raft协议的头领选举算法, sentinel发现master进入客观下线状态,会向其他sentinel发送消息推举自己为leader; 当某个sentinel获得超过半数票时,会将自身设置成leader,并将信息同步给其他sentinel;
- 每个节点都有一个配置纪元(计数器),收到相关选举消息时会对比配置纪元,确定是当前配置纪元的选举才会参与; 每次投票完配置纪元+1;

### redis分布式，如何减少同步延迟
要先确定同步延迟产生的原因: 
- redis瓶颈通常是网络IO: 首先看是不是网速的原因, 保证集群在同一个交换机下面, 带宽足够大;
- redis一些参数配置是否不正确;
- 程序最好能在设计时容忍一部分延迟(比如订单缓存,可以提示用户订单同步有1-2分钟延迟);也可以写程序用来监控主从的复制偏移量,暂时禁用掉延迟过大的从库;
- 加大服务器配置,redis的设备瓶颈通常是内存;
- 减少同步的从节点数量;

### redis容灾，备份，扩容
- 容灾: sentinel
- 备份: RDB, AOF
- 扩容: redis-trib工具 横向增加新节点;(同构平分slots,异构按性能分slots)


### redis cluster有没有了解过，怎么做到高可用的？
cluster的高可用是通过slave来做的:
- slave检测到master变成fail, 会向其他有投票权(分配了slots)的node发送消息要求给自己投票;
- 其他node在当前配置纪元收到的第一条FAILOVER_REQUEST消息, 会给slave 回复ACK消息;
- slave统计得票,如果超过半数node给自己投票,则slave宣布自己成为master,同时执行`slaveof no one`,并广播自己的信息给其他节点;

