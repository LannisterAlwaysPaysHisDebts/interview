# 分布式/微服务相关QA

## QA index
- [分布式基础QA](./base.md)
- [分布式高可用QA](./HA.md)
- [消息队列QA](./MQ.md)
- [redis面试QA](./redis.md)
- [mysql面试QA](./mysql.md)

## tech index
- [redis相关知识补充](./redis-base.md)
- [mysql相关知识补充](./mysql-base.md)


## 服务端编程的3大性能杀手
1. 大量线程导致的线程切换开销;
2. 锁;
3. 非必要的内存拷贝;

但是这三项很少成为瓶颈, 更大的瓶颈在于硬盘、网卡与upstream服务;

## 常用的中间件
- 缓存: redis
- 消息队列: rabbitMQ、rocketMQ、kafka
- 链路追踪: jaeger、opentracing、
- 服务治理: consul、zookeeper、etcd
- 日志: zap日志、 elk
- 监控: promethues + grafana
- 高可用: 三板斧:熔断、降级、限流
- 负载均衡
    
### 成熟的调用链开源工具:
- Google Dapper:
- 阿里家的EagleEye: 
- 美团家的MTrace

### 熔断降级限流
- [guava](https://github.com/google/guava)
- [ratelimit](https://github.com/uber-go/ratelimit)
- [sentinel](https://github.com/alibaba/Sentinel)
- [hystrix](https://github.com/Netflix/Hystrix)


## 分布式微服务体系结构与重点
- 项目满足: 高并发、高可用、高性能;
- 核心问题: 1. 如何应对瞬时高并发流量; 2. 如何防止超卖; 3. 如何保证服务高可用; 4. 如何实现弹性架构拓展; 5. 如何防范恶意请求;
- 应对瞬时高并发流量: 利用消息中间件进行流量削峰、分布式ID解决方案、RocketMQ、订单处理与消息队列的结合;
- 超卖: 库存扣减方案、库存超卖问题与多种解决方案分析、Jmeter并发请求测试、 使用Lua脚本解决库存超卖问题
- 预热缓存以降低数据库压力、CDN 流量分发、页面静态化
- 限流: 前端限流策略、接口限流、[流量控制](https://github.com/alibaba/Sentinel)、 防爬虫与恶意刷请求
- 分布式锁、Redis 是如何实现原子操作的、如何防范缓存穿透 & 缓存击穿 & 缓存雪崩
- 分布式事务


## 系统设计流程与架构演进
### 技术选型
#### 项目初期
- 初期快速实现, all in one架构, 直接JAVA或者PHP技术栈;这个阶段主要是CURD实现业务,引入DAO层与ORM可以加快开发效率;

- 出现三种情况之一: 1. 新系统上线; 2. 运营活动; 3. 项目有质变性增长;  此时考虑开始优化, 能用钱解决的问题,直接升级配置; 或者将all in one架构升级成伪分布式架构;

- 伪分布式架构其实就只是把业务、数据库与代码垂直拆分; 

- 此时可以考虑微服务架构: （1）代码频繁拷贝；（2）底层复杂性扩散；（3）公共库耦合；（4）SQL质量不可控，数据库性能急剧下降；（5）数据库耦合，无法实现增加实例扩容；

- 微服务架构必须要考虑: 1. 高可用; 2. 无限水平扩展; 3. 负载均衡; 


#### 出现性能瓶颈怎么办?
- 前端加载问题: 页面静态化,走CDN; 
- 最容易出现的问题: 数据库读瓶颈, 解决方法:读写分离; 另外后台运营系统的复杂sql可能对db有性能影响, 此时做前后台分离;(比较简单的方法?指定读库) 
- 读写分离还是hold不住大流量, 解决读的问题, 引入redis做缓存; redis可以做高可用,也可以做cluster;

    读最佳实践: 读缓存,命中返回,不命中查库,再设置缓存; 写最佳实践: 1. 淘汰缓存而不是修改缓存; 2. 先操作数据库,再操作缓存; (update之后立即del缓存)

- 高并发写的情景, redis不能处理这种情况,因为数据可能随时被LRU, 只能mysql事务处理;解决办法是写请求全部灌入MQ, 后面消费者慢慢写;





