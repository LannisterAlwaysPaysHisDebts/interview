# 中间件 QA

## index
- [redis面试QA](./redis.md)
- [redis面试相关知识补充](./redis-base.md)
- [mysql面试QA](./mysql.md)
- [mysql相关知识补充](./mysql-base.md)
- [mysql索引优化实例](./mysql-scene.md)
- [kafka面试QA](./kafka.md)


## 常用的中间件
- 缓存: redis
- 消息队列: rabbitMQ、rocketMQ、kafka
- 链路追踪: jaeger、opentracing、
- 服务治理: consul、zookeeper、etcd
- 日志: zap日志、 elk
- 监控: promethues + grafana
- 高可用: 
    - 熔断: hystrix
    - 降级: 
    - 限流: guava、ratelimit、sentinel
    - 负载均衡: 


## 系统设计流程与架构演进
### 技术选型
#### 项目初期
- 初期快速实现, all in one架构, 直接JAVA或者PHP技术栈;这个阶段主要是CURD实现业务,引入DAO层与ORM可以加快开发效率;

- 出现三种情况之一: 1. 新系统上线; 2. 运营活动; 3. 项目有质变性增长;  此时考虑开始优化, 能用钱解决的问题,直接升级配置; 或者将all in one架构升级成伪分布式架构;

- 伪分布式架构其实就只是把业务、数据库与代码垂直拆分; 

- 此时可以考虑微服务架构: （1）代码频繁拷贝；（2）底层复杂性扩散；（3）公共库耦合；（4）SQL质量不可控，数据库性能急剧下降；（5）数据库耦合，无法实现增加实例扩容；

- 微服务架构必须要考虑: 1. 高可用; 2. 无限水平扩展; 3. 负载均衡; 


#### 出现性能瓶颈怎么办?
- 前端加载问题: 页面静态化,走CDN; 
- 最容易出现的问题: 数据库读瓶颈, 解决方法:读写分离; 另外后台运营系统的复杂sql可能对db有性能影响, 此时做前后台分离;(比较简单的方法?指定读库) 
- 读写分离还是hold不住大流量, 解决读的问题, 引入redis做缓存; redis可以做高可用,也可以做cluster;

    读最佳实践: 读缓存,命中返回,不命中查库,再设置缓存; 写最佳实践: 1. 淘汰缓存而不是修改缓存; 2. 先操作数据库,再操作缓存; (update之后立即del缓存)

- 高并发写的情景, redis不能处理这种情况,因为数据可能随时被LRU, 只能mysql事务处理;解决办法是写请求全部灌入MQ, 后面消费者慢慢写;





